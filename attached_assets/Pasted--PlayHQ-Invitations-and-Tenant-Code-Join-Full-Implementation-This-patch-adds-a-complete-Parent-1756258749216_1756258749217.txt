# PlayHQ Invitations and Tenant Code Join - Full Implementation

This patch adds a complete Parent and Player invitation system with tenant codes, using Express, Drizzle ORM with PostgreSQL, SendGrid, and a React admin UI. Files are grouped by path. Adjust imports to match your repo structure.

---

## server/db/schema/invite.ts
```ts
import { pgTable, uuid, varchar, text, timestamp, boolean, jsonb, index, uniqueIndex } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { users } from "./user";
import { tenants } from "./tenant";

export const tenantInviteCodes = pgTable("tenant_invite_codes", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: uuid("tenant_id").notNull().references(() => tenants.id, { onDelete: "cascade" }),
  code: varchar("code", { length: 64 }).notNull(),
  isActive: boolean("is_active").notNull().default(true),
  createdByAdminId: uuid("created_by_admin_id").references(() => users.id),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  rotatedAt: timestamp("rotated_at", { withTimezone: true }),
  rotatedByAdminId: uuid("rotated_by_admin_id").references(() => users.id),
  notes: varchar("notes", { length: 512 }),
}, (t) => ({
  tenantActiveIdx: index("tenant_invite_codes_tenant_active_idx").on(t.tenantId, t.isActive),
}));

export const invitations = pgTable("invitations", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: uuid("tenant_id").notNull().references(() => tenants.id, { onDelete: "cascade" }),
  createdByAdminId: uuid("created_by_admin_id").notNull().references(() => users.id),
  inviteeEmail: varchar("invitee_email", { length: 256 }).notNull(),
  inviteeName: varchar("invitee_name", { length: 256 }),
  role: text("role", { enum: ["parent", "player"] }).notNull(),
  tokenHash: varchar("token_hash", { length: 256 }).notNull(),
  tokenExpiresAt: timestamp("token_expires_at", { withTimezone: true }).notNull(),
  status: text("status", { enum: ["pending", "sent", "accepted", "expired", "revoked", "bounced"] }).notNull().default("sent"),
  sentAt: timestamp("sent_at", { withTimezone: true }).notNull().defaultNow(),
  acceptedAt: timestamp("accepted_at", { withTimezone: true }),
  revokedAt: timestamp("revoked_at", { withTimezone: true }),
  bouncedAt: timestamp("bounced_at", { withTimezone: true }),
  lastSentAt: timestamp("last_sent_at", { withTimezone: true }),
  lastError: varchar("last_error", { length: 512 }),
  metadata: jsonb("metadata").$type<Record<string, unknown>>()
}, (t) => ({
  byTenantEmailRolePending: uniqueIndex("invitations_tenant_email_role_unique")
    .on(t.tenantId, t.inviteeEmail, t.role, t.status),
  tenantIdx: index("invitations_tenant_idx").on(t.tenantId),
  emailIdx: index("invitations_email_idx").on(t.inviteeEmail),
}));

export const inviteEvents = pgTable("invite_events", {
  id: uuid("id").primaryKey().defaultRandom(),
  invitationId: uuid("invitation_id").notNull().references(() => invitations.id, { onDelete: "cascade" }),
  actorAdminId: uuid("actor_admin_id").references(() => users.id),
  eventType: text("event_type", { enum: ["created", "sent", "resent", "accepted", "expired", "revoked", "bounced"] }).notNull(),
  eventData: jsonb("event_data").$type<Record<string, unknown>>(),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
});

export const blockedEmails = pgTable("blocked_emails", {
  id: uuid("id").primaryKey().defaultRandom(),
  email: varchar("email", { length: 256 }).notNull(),
  reason: varchar("reason", { length: 256 }),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
}, (t) => ({
  emailUnique: uniqueIndex("blocked_emails_email_unique").on(t.email),
}));

export const allowedEmailDomains = pgTable("allowed_email_domains", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: uuid("tenant_id").notNull().references(() => tenants.id, { onDelete: "cascade" }),
  domain: varchar("domain", { length: 128 }).notNull(),
});

export const userTenantMemberships = pgTable("user_tenant_memberships", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  tenantId: uuid("tenant_id").notNull().references(() => tenants.id, { onDelete: "cascade" }),
  role: text("role", { enum: ["admin", "parent", "player"] }).notNull(),
  status: text("status", { enum: ["active", "suspended"] }).notNull().default("active"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  createdByAdminId: uuid("created_by_admin_id").references(() => users.id),
}, (t) => ({
  byUserTenantUnique: uniqueIndex("user_tenant_memberships_user_tenant_unique").on(t.userId, t.tenantId),
}));

export const invitationsRelations = relations(invitations, ({ one }) => ({
  tenant: one(tenants, { fields: [invitations.tenantId], references: [tenants.id] }),
}));
```

---

## server/lib/tokens.ts
```ts
import crypto from "crypto";

export function createToken(length = 48) {
  return crypto.randomBytes(length).toString("hex");
}

export async function hashToken(token: string): Promise<string> {
  const salt = crypto.randomBytes(16);
  const derivedKey = await new Promise<Buffer>((resolve, reject) => {
    crypto.scrypt(token, salt, 64, (err, dk) => {
      if (err) reject(err);
      else resolve(dk as Buffer);
    });
  });
  return `${salt.toString("hex")}:${derivedKey.toString("hex")}`;
}

export async function verifyToken(token: string, stored: string): Promise<boolean> {
  const [saltHex, hashHex] = stored.split(":");
  const salt = Buffer.from(saltHex, "hex");
  const derivedKey = await new Promise<Buffer>((resolve, reject) => {
    crypto.scrypt(token, salt, 64, (err, dk) => {
      if (err) reject(err);
      else resolve(dk as Buffer);
    });
  });
  const expected = Buffer.from(hashHex, "hex");
  return crypto.timingSafeEqual(derivedKey, expected);
}
```

---

## server/lib/email.ts
```ts
import sgMail from "@sendgrid/mail";

const SENDGRID_FROM_NAME = process.env.SENDGRID_FROM_NAME || "PlayHQ";
const SENDGRID_FROM_ADDRESS = process.env.SENDGRID_FROM_ADDRESS || "no-reply@playhq.com";
const TEMPLATE_INVITE = process.env.SENDGRID_TEMPLATE_INVITE as string;

if (!process.env.SENDGRID_API_KEY) {
  throw new Error("SENDGRID_API_KEY is not set");
}
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

export async function sendInviteEmail(args: {
  to: string;
  role: "parent" | "player";
  tenantName: string;
  tenantLogoUrl?: string | null;
  inviterName: string;
  joinLink: string;
  joinCode?: string | null;
  expirationText: string;
  note?: string | null;
}) {
  const msg = {
    to: args.to,
    from: {
      email: SENDGRID_FROM_ADDRESS,
      name: SENDGRID_FROM_NAME,
    },
    templateId: TEMPLATE_INVITE,
    dynamic_template_data: {
      tenant_name: args.tenantName,
      tenant_logo_url: args.tenantLogoUrl,
      inviter_name: args.inviterName,
      role: args.role,
      join_link: args.joinLink,
      join_code: args.joinCode,
      expiration_text: args.expirationText,
      note: args.note,
      support_contact: "support@playhq.com",
    },
  } as any;
  await sgMail.send(msg);
}
```

---

## server/middleware/auth.ts
```ts
import { Request, Response, NextFunction } from "express";

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (req.user) return next();
  return res.status(401).json({ error: "Sign in required" });
}

export function requireAdmin(req: Request, res: Response, next: NextFunction) {
  if (req.user && req.user.role === "admin" && req.user.tenantId) return next();
  return res.status(403).json({ error: "Admin access required" });
}
```

---

## server/validation/invitations.ts
```ts
import { z } from "zod";

export const InviteCreateSchema = z.object({
  email: z.string().email(),
  role: z.enum(["parent", "player"]),
  name: z.string().min(1).max(256).optional(),
  note: z.string().max(512).optional(),
  expiresInDays: z.number().int().min(1).max(60).optional(),
});

export const InviteListQuerySchema = z.object({
  status: z.enum(["pending", "sent", "accepted", "expired", "revoked", "bounced"]).optional(),
  role: z.enum(["parent", "player"]).optional(),
  email: z.string().optional(),
  createdBy: z.string().uuid().optional(),
  page: z.number().int().min(1).default(1).optional(),
  pageSize: z.number().int().min(1).max(100).default(20).optional(),
});

export const TokenValidateSchema = z.object({ token: z.string().min(16) });
export const CodeValidateSchema = z.object({ code: z.string().min(4) });

export const AcceptByTokenSchema = z.object({
  token: z.string().min(16),
  email: z.string().email(),
  password: z.string().min(8),
});

export const AcceptByCodeSchema = z.object({
  code: z.string().min(4),
  role: z.enum(["parent", "player"]),
  email: z.string().email(),
  name: z.string().min(1).max(256).optional(),
  password: z.string().min(8),
});
```

---

## server/routes/invites.ts
```ts
import express from "express";
import { db } from "../db";
import { invitations, inviteEvents, tenantInviteCodes, blockedEmails } from "../db/schema/invite";
import { tenants } from "../db/schema/tenant";
import { users } from "../db/schema/user";
import { and, desc, eq, ilike, sql } from "drizzle-orm";
import { InviteCreateSchema, InviteListQuerySchema } from "../validation/invitations";
import { createToken, hashToken } from "../lib/tokens";
import { requireAdmin } from "../middleware/auth";
import { sendInviteEmail } from "../lib/email";

const APP_URL = process.env.APP_URL || "http://localhost:5173";

const router = express.Router();

router.post("/", requireAdmin, async (req, res) => {
  const parsed = InviteCreateSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const { email, role, name, note, expiresInDays } = parsed.data;

  const adminUser = req.user! as any;
  const tenantId = adminUser.tenantId as string;

  const blocked = await db.query.blockedEmails.findFirst({ where: eq(blockedEmails.email, email) });
  if (blocked) return res.status(400).json({ error: "Email is blocked due to previous bounces or complaints" });

  const token = createToken(32);
  const tokenHash = await hashToken(token);
  const expires = new Date();
  expires.setDate(expires.getDate() + (expiresInDays ?? 7));

  const [tenant] = await db.select().from(tenants).where(eq(tenants.id, tenantId));
  if (!tenant) return res.status(404).json({ error: "Tenant not found" });

  const [activeCode] = await db.select().from(tenantInviteCodes)
    .where(and(eq(tenantInviteCodes.tenantId, tenantId), eq(tenantInviteCodes.isActive, true)));

  const invite = await db.insert(invitations).values({
    tenantId,
    createdByAdminId: adminUser.id,
    inviteeEmail: email,
    inviteeName: name,
    role,
    tokenHash,
    tokenExpiresAt: expires,
    status: "sent",
  }).returning();

  await db.insert(inviteEvents).values({
    invitationId: invite[0].id,
    actorAdminId: adminUser.id,
    eventType: "created",
  });
  await db.insert(inviteEvents).values({
    invitationId: invite[0].id,
    actorAdminId: adminUser.id,
    eventType: "sent",
  });

  const joinLink = `${APP_URL}/join?token=${encodeURIComponent(token)}`;
  await sendInviteEmail({
    to: email,
    role,
    tenantName: tenant.name,
    tenantLogoUrl: (tenant as any).logoUrl || null,
    inviterName: adminUser.name || "Admin",
    joinLink,
    joinCode: activeCode?.code ?? null,
    expirationText: `This link expires on ${expires.toLocaleDateString()}`,
    note: note || null,
  });

  return res.json({ id: invite[0].id, joinLink });
});

router.get("/", requireAdmin, async (req, res) => {
  const parsed = InviteListQuerySchema.safeParse({
    status: req.query.status,
    role: req.query.role,
    email: req.query.email,
    createdBy: req.query.createdBy,
    page: req.query.page ? Number(req.query.page) : 1,
    pageSize: req.query.pageSize ? Number(req.query.pageSize) : 20,
  });
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const q = parsed.data;

  const adminUser = req.user! as any;
  const tenantId = adminUser.tenantId as string;

  const where = and(
    eq(invitations.tenantId, tenantId),
    q.status ? eq(invitations.status, q.status) : sql`true`,
    q.role ? eq(invitations.role, q.role) : sql`true`,
    q.email ? ilike(invitations.inviteeEmail, `%${q.email}%`) : sql`true`,
  );

  const [items, [{ count }]] = await Promise.all([
    db.select().from(invitations).where(where).orderBy(desc(invitations.sentAt))
      .limit(q.pageSize!).offset((q.page! - 1) * q.pageSize!),
    db.select({ count: sql<number>`count(*)` }).from(invitations).where(where),
  ]);

  res.json({ items, page: q.page, pageSize: q.pageSize, total: Number(count) });
});

router.post(`/:id/resend`, requireAdmin, async (req, res) => {
  const id = req.params.id;
  const adminUser = req.user! as any;
  const [invite] = await db.select().from(invitations).where(eq(invitations.id, id));
  if (!invite) return res.status(404).json({ error: "Invite not found" });
  if (invite.status === "revoked" || invite.status === "accepted") return res.status(400).json({ error: "Cannot resend" });

  const [tenant] = await db.select().from(tenants).where(eq(tenants.id, invite.tenantId));
  const [activeCode] = await db.select().from(tenantInviteCodes)
    .where(and(eq(tenantInviteCodes.tenantId, invite.tenantId), eq(tenantInviteCodes.isActive, true)));

  // create a fresh token and update
  const token = createToken(32);
  const tokenHash = await hashToken(token);
  const expires = new Date();
  expires.setDate(expires.getDate() + 7);

  await db.update(invitations).set({ tokenHash, tokenExpiresAt: expires, lastSentAt: new Date(), status: "sent" }).where(eq(invitations.id, id));
  await db.insert(inviteEvents).values({ invitationId: id, actorAdminId: adminUser.id, eventType: "resent" });

  const joinLink = `${APP_URL}/join?token=${encodeURIComponent(token)}`;
  await sendInviteEmail({
    to: invite.inviteeEmail,
    role: invite.role as any,
    tenantName: (tenant as any).name,
    tenantLogoUrl: (tenant as any).logoUrl || null,
    inviterName: adminUser.name || "Admin",
    joinLink,
    joinCode: activeCode?.code ?? null,
    expirationText: `This link expires on ${expires.toLocaleDateString()}`,
  });

  return res.json({ ok: true, joinLink });
});

router.post(`/:id/revoke`, requireAdmin, async (req, res) => {
  const id = req.params.id;
  const adminUser = req.user! as any;
  const [invite] = await db.select().from(invitations).where(eq(invitations.id, id));
  if (!invite) return res.status(404).json({ error: "Invite not found" });
  if (invite.status === "accepted") return res.status(400).json({ error: "Cannot revoke an accepted invite" });

  await db.update(invitations).set({ status: "revoked", revokedAt: new Date() }).where(eq(invitations.id, id));
  await db.insert(inviteEvents).values({ invitationId: id, actorAdminId: adminUser.id, eventType: "revoked" });

  return res.json({ ok: true });
});

export default router;
```

---

## server/routes/join.ts
```ts
import express from "express";
import { db } from "../db";
import { invitations, inviteEvents, tenantInviteCodes, userTenantMemberships } from "../db/schema/invite";
import { tenants } from "../db/schema/tenant";
import { users } from "../db/schema/user";
import { and, eq } from "drizzle-orm";
import { AcceptByCodeSchema, AcceptByTokenSchema, CodeValidateSchema, TokenValidateSchema } from "../validation/invitations";
import { verifyToken } from "../lib/tokens";

const router = express.Router();

router.get("/validate-token", async (req, res) => {
  const parsed = TokenValidateSchema.safeParse({ token: req.query.token });
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const token = parsed.data.token;

  // We cannot find by token directly, so we return success only after accept. For UX we can skip deep validation here.
  return res.json({ ok: true });
});

router.post("/accept-token", async (req, res) => {
  const parsed = AcceptByTokenSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const { token, email, password } = parsed.data;

  // Find a matching invitation by brute force compare of hashes for invites in a reasonable window
  const now = new Date();
  const candidates = await db.select().from(invitations).where(and(eq(invitations.inviteeEmail, email)));
  const invite = (await Promise.all(candidates.map(async (i) => {
    const ok = await verifyToken(token, i.tokenHash);
    return ok ? i : null;
  }))).find(Boolean) as typeof candidates[number] | undefined;

  if (!invite) return res.status(400).json({ error: "Invalid or expired token" });
  if (invite.status === "revoked" || invite.status === "bounced") return res.status(400).json({ error: "Invite is not valid" });
  if (invite.tokenExpiresAt < now) {
    await db.update(invitations).set({ status: "expired" }).where(eq(invitations.id, invite.id));
    await db.insert(inviteEvents).values({ invitationId: invite.id, eventType: "expired" });
    return res.status(400).json({ error: "Invite expired" });
  }

  const [tenant] = await db.select().from(tenants).where(eq(tenants.id, invite.tenantId));
  if (!tenant) return res.status(404).json({ error: "Tenant not found" });

  // Create or fetch user, then membership
  let [user] = await db.select().from(users).where(eq(users.email, email));
  if (!user) {
    const created = await db.insert(users).values({ email, name: invite.inviteeName || null, passwordHash: await fakeHashPassword(password) }).returning();
    user = created[0];
  }

  await upsertMembership(user.id, invite.tenantId, invite.role as any, invite.createdByAdminId);

  await db.update(invitations).set({ status: "accepted", acceptedAt: new Date() }).where(eq(invitations.id, invite.id));
  await db.insert(inviteEvents).values({ invitationId: invite.id, eventType: "accepted" });

  // TODO issue session cookie here using your existing auth logic
  res.json({ ok: true, tenantId: invite.tenantId });
});

router.get("/validate-code", async (req, res) => {
  const parsed = CodeValidateSchema.safeParse({ code: req.query.code });
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const { code } = parsed.data;
  const [row] = await db.select().from(tenantInviteCodes).where(and(eq(tenantInviteCodes.code, code), eq(tenantInviteCodes.isActive, true)));
  if (!row) return res.status(404).json({ error: "Code not found" });
  const [tenant] = await db.select().from(tenants).where(eq(tenants.id, row.tenantId));
  return res.json({ ok: true, tenantId: row.tenantId, tenantName: (tenant as any)?.name });
});

router.post("/accept-code", async (req, res) => {
  const parsed = AcceptByCodeSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const { code, role, email, name, password } = parsed.data;

  const [row] = await db.select().from(tenantInviteCodes).where(and(eq(tenantInviteCodes.code, code), eq(tenantInviteCodes.isActive, true)));
  if (!row) return res.status(404).json({ error: "Code not found" });

  let [user] = await db.select().from(users).where(eq(users.email, email));
  if (!user) {
    const created = await db.insert(users).values({ email, name: name || null, passwordHash: await fakeHashPassword(password) }).returning();
    user = created[0];
  }

  await upsertMembership(user.id, row.tenantId, role, null);

  // TODO issue session cookie here using your existing auth logic
  res.json({ ok: true, tenantId: row.tenantId });
});

async function upsertMembership(userId: string, tenantId: string, role: "parent" | "player", createdByAdminId: string | null) {
  const existing = await db.select().from(userTenantMemberships).where(and(
    eq(userTenantMemberships.userId, userId),
    eq(userTenantMemberships.tenantId, tenantId),
  ));
  if (existing.length === 0) {
    await db.insert(userTenantMemberships).values({ userId, tenantId, role, createdByAdminId });
  }
}

async function fakeHashPassword(password: string) {
  // Replace with your real password hashing
  return password + "_hash";
}

export default router;
```

---

## server/routes/tenants.ts
```ts
import express from "express";
import { db } from "../db";
import { tenantInviteCodes } from "../db/schema/invite";
import { requireAdmin } from "../middleware/auth";
import { eq, and } from "drizzle-orm";
import crypto from "crypto";

const router = express.Router();

router.get("/invite-code", requireAdmin, async (req, res) => {
  const tenantId = (req.user as any).tenantId as string;
  const [row] = await db.select().from(tenantInviteCodes).where(and(eq(tenantInviteCodes.tenantId, tenantId), eq(tenantInviteCodes.isActive, true)));
  if (!row) return res.json({ code: null });
  res.json({ code: row.code });
});

router.post("/invite-code/rotate", requireAdmin, async (req, res) => {
  const admin = req.user as any;
  const tenantId = admin.tenantId as string;
  await db.update(tenantInviteCodes)
    .set({ isActive: false, rotatedAt: new Date(), rotatedByAdminId: admin.id })
    .where(and(eq(tenantInviteCodes.tenantId, tenantId), eq(tenantInviteCodes.isActive, true)));

  const code = crypto.randomBytes(6).toString("hex");
  const [created] = await db.insert(tenantInviteCodes).values({
    tenantId,
    code,
    isActive: true,
    createdByAdminId: admin.id,
  }).returning();

  res.json({ code: created.code });
});

export default router;
```

---

## server/routes/sendgrid.ts
```ts
import express from "express";
import { db } from "../db";
import { blockedEmails, invitations } from "../db/schema/invite";
import { eq } from "drizzle-orm";

const router = express.Router();

// Configure SendGrid Event Webhook to POST here with events like bounce and spamreport
router.post("/sendgrid/events", express.json({ type: "application/json" }), async (req, res) => {
  const events = req.body as Array<any>;
  try {
    for (const e of events) {
      if (e.event === "bounce" || e.event === "spamreport") {
        const email = e.email as string;
        await db.insert(blockedEmails).values({ email, reason: e.event }).onConflictDoNothing();
        // If we have invitation ids in custom args we can update status
        const inviteId = e?.custom_args?.invite_id as string | undefined;
        if (inviteId) {
          await db.update(invitations).set({ status: "bounced", bouncedAt: new Date(), lastError: e.reason || e.sg_message_id })
            .where(eq(invitations.id, inviteId));
        }
      }
    }
    res.json({ ok: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Webhook processing failed" });
  }
});

export default router;
```

---

## server/index.ts additions
```ts
import express from "express";
import invitesRouter from "./routes/invites";
import joinRouter from "./routes/join";
import tenantsRouter from "./routes/tenants";
import sendgridWebhookRouter from "./routes/sendgrid";

// after app is created
app.use("/api/invites", invitesRouter);
app.use("/api/join", joinRouter);
app.use("/api/tenants", tenantsRouter);
app.use("/api/webhooks", sendgridWebhookRouter);
```

---

## client/src/lib/api.ts
```ts
export async function api<T = any>(path: string, opts: RequestInit = {}) {
  const res = await fetch(`/api${path}`, {
    credentials: "include",
    headers: { "Content-Type": "application/json", ...(opts.headers || {}) },
    ...opts,
  });
  if (!res.ok) throw new Error(await res.text());
  return res.json() as Promise<T>;
}
```

---

## client/src/pages/admin/Invitations.tsx
```tsx
import { useEffect, useMemo, useState } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Card, CardHeader, CardContent, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue } from "@/components/ui/select";
import { api } from "@/lib/api";

function Stats({ counts }: { counts: Record<string, number> }) {
  return (
    <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
      {Object.entries(counts).map(([k, v]) => (
        <Card key={k} className="shadow">
          <CardHeader className="py-2"><CardTitle className="text-sm">{k}</CardTitle></CardHeader>
          <CardContent className="text-2xl font-semibold">{v}</CardContent>
        </Card>
      ))}
    </div>
  );
}

export default function InvitationsPage() {
  const qc = useQueryClient();
  const [filters, setFilters] = useState({ status: "", role: "", email: "" });

  const { data, isLoading, refetch } = useQuery({
    queryKey: ["invites", filters],
    queryFn: async () => {
      const params = new URLSearchParams();
      if (filters.status) params.set("status", filters.status);
      if (filters.role) params.set("role", filters.role);
      if (filters.email) params.set("email", filters.email);
      return api<{ items: any[]; total: number }>(`/invites?${params.toString()}`);
    },
  });

  const createInvite = useMutation({
    mutationFn: async (payload: { email: string; role: "parent" | "player"; name?: string; note?: string; expiresInDays?: number }) => {
      return api(`/invites`, { method: "POST", body: JSON.stringify(payload) });
    },
    onSuccess: () => qc.invalidateQueries({ queryKey: ["invites"] }),
  });

  const resendInvite = useMutation({
    mutationFn: async (id: string) => api(`/invites/${id}/resend`, { method: "POST" }),
    onSuccess: () => qc.invalidateQueries({ queryKey: ["invites"] }),
  });

  const revokeInvite = useMutation({
    mutationFn: async (id: string) => api(`/invites/${id}/revoke", { method: "POST" }),
    onSuccess: () => qc.invalidateQueries({ queryKey: ["invites"] }),
  });

  const [form, setForm] = useState({ email: "", role: "parent", name: "", note: "", expiresInDays: 7 });

  const counts = useMemo(() => {
    const c: Record<string, number> = { Pending: 0, Sent: 0, Accepted: 0, Expired: 0, Revoked: 0, Bounced: 0 };
    for (const it of data?.items || []) {
      const s = String(it.status || "").toLowerCase();
      if (s === "pending") c.Pending++;
      if (s === "sent") c.Sent++;
      if (s === "accepted") c.Accepted++;
      if (s === "expired") c.Expired++;
      if (s === "revoked") c.Revoked++;
      if (s === "bounced") c.Bounced++;
    }
    return c;
  }, [data]);

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Invitations</h1>
        <TenantCodeCard />
      </div>

      <Stats counts={counts} />

      <Card className="shadow">
        <CardHeader><CardTitle>Create invitation</CardTitle></CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
            <Input placeholder="Email" value={form.email} onChange={(e) => setForm({ ...form, email: e.target.value })} />
            <Select value={form.role} onValueChange={(v) => setForm({ ...form, role: v as any })}>
              <SelectTrigger><SelectValue placeholder="Role" /></SelectTrigger>
              <SelectContent>
                <SelectItem value="parent">Parent</SelectItem>
                <SelectItem value="player">Player</SelectItem>
              </SelectContent>
            </Select>
            <Input placeholder="Name optional" value={form.name} onChange={(e) => setForm({ ...form, name: e.target.value })} />
            <Input placeholder="Expiration days" type="number" value={form.expiresInDays}
              onChange={(e) => setForm({ ...form, expiresInDays: Number(e.target.value) })} />
          </div>
          <Input placeholder="Note to include optional" value={form.note} onChange={(e) => setForm({ ...form, note: e.target.value })} />
          <div className="flex gap-2">
            <Button onClick={() => createInvite.mutate(form)} disabled={createInvite.isPending}>Send invite</Button>
            {createInvite.data?.joinLink && (
              <Button variant="outline" onClick={() => navigator.clipboard.writeText(createInvite.data.joinLink)}>Copy link</Button>
            )}
          </div>
        </CardContent>
      </Card>

      <Card className="shadow">
        <CardHeader><CardTitle>Invites</CardTitle></CardHeader>
        <CardContent className="space-y-3">
          <div className="flex flex-wrap gap-2">
            <Input placeholder="Filter email" value={filters.email} onChange={(e) => setFilters({ ...filters, email: e.target.value })} />
            <Select value={filters.role} onValueChange={(v) => setFilters({ ...filters, role: v })}>
              <SelectTrigger className="w-40"><SelectValue placeholder="Role" /></SelectTrigger>
              <SelectContent>
                <SelectItem value="">All roles</SelectItem>
                <SelectItem value="parent">Parent</SelectItem>
                <SelectItem value="player">Player</SelectItem>
              </SelectContent>
            </Select>
            <Select value={filters.status} onValueChange={(v) => setFilters({ ...filters, status: v })}>
              <SelectTrigger className="w-40"><SelectValue placeholder="Status" /></SelectTrigger>
              <SelectContent>
                <SelectItem value="">All status</SelectItem>
                <SelectItem value="sent">Sent</SelectItem>
                <SelectItem value="accepted">Accepted</SelectItem>
                <SelectItem value="expired">Expired</SelectItem>
                <SelectItem value="revoked">Revoked</SelectItem>
                <SelectItem value="bounced">Bounced</SelectItem>
              </SelectContent>
            </Select>
            <Button variant="outline" onClick={() => refetch()}>Apply</Button>
          </div>

          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead>
                <tr className="text-left">
                  <th className="p-2">Email</th>
                  <th className="p-2">Role</th>
                  <th className="p-2">Status</th>
                  <th className="p-2">Expires</th>
                  <th className="p-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {data?.items?.map((it: any) => (
                  <tr key={it.id} className="border-t">
                    <td className="p-2">{it.inviteeEmail}</td>
                    <td className="p-2 capitalize">{it.role}</td>
                    <td className="p-2 capitalize">{it.status}</td>
                    <td className="p-2">{it.tokenExpiresAt ? new Date(it.tokenExpiresAt).toLocaleDateString() : ""}</td>
                    <td className="p-2 flex gap-2">
                      <Button size="sm" variant="outline" onClick={() => resendInvite.mutate(it.id)}>Resend</Button>
                      <Button size="sm" variant="outline" onClick={() => revokeInvite.mutate(it.id)}>Revoke</Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

function TenantCodeCard() {
  const { data, refetch } = useQuery({ queryKey: ["tenant-code"], queryFn: () => api<{ code: string | null }>(`/tenants/invite-code`) });
  const rotate = useMutation({ mutationFn: async () => api<{ code: string }>(`/tenants/invite-code/rotate`, { method: "POST" }), onSuccess: () => refetch() });
  return (
    <Card className="shadow w-full max-w-sm">
      <CardHeader className="pb-2"><CardTitle className="text-base">Tenant code</CardTitle></CardHeader>
      <CardContent className="space-y-2">
        <div className="flex items-center gap-2">
          <Input readOnly value={data?.code || "None"} />
          <Button variant="outline" onClick={() => data?.code && navigator.clipboard.writeText(data.code)}>Copy</Button>
        </div>
        <Button onClick={() => rotate.mutate()} disabled={rotate.isPending}>Rotate</Button>
      </CardContent>
    </Card>
  );
}
```

---

## client/src/pages/Join.tsx
```tsx
import { useEffect, useMemo, useState } from "react";
import { useLocation } from "wouter";
import { useMutation } from "@tanstack/react-query";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue } from "@/components/ui/select";
import { api } from "@/lib/api";

export default function JoinPage() {
  const [loc, setLoc] = useLocation();
  const params = new URLSearchParams(window.location.search);
  const token = params.get("token");

  const [form, setForm] = useState({ email: "", password: "", name: "", role: "parent", code: "" });

  const acceptToken = useMutation({
    mutationFn: async () => api(`/join/accept-token`, { method: "POST", body: JSON.stringify({ token, email: form.email, password: form.password }) }),
    onSuccess: (r: any) => setLoc(`/tenant/${r.tenantId}`),
  });

  const acceptCode = useMutation({
    mutationFn: async () => api(`/join/accept-code`, { method: "POST", body: JSON.stringify({ code: form.code, role: form.role, email: form.email, name: form.name, password: form.password }) }),
    onSuccess: (r: any) => setLoc(`/tenant/${r.tenantId}`),
  });

  if (token) {
    return (
      <div className="max-w-md mx-auto py-10 space-y-4">
        <h1 className="text-2xl font-semibold">Accept invitation</h1>
        <Input placeholder="Email" value={form.email} onChange={(e) => setForm({ ...form, email: e.target.value })} />
        <Input placeholder="Password" type="password" value={form.password} onChange={(e) => setForm({ ...form, password: e.target.value })} />
        <Button onClick={() => acceptToken.mutate()} disabled={acceptToken.isPending}>Join</Button>
      </div>
    );
  }

  return (
    <div className="max-w-md mx-auto py-10 space-y-4">
      <h1 className="text-2xl font-semibold">Join a tenant</h1>
      <Input placeholder="Tenant code" value={form.code} onChange={(e) => setForm({ ...form, code: e.target.value })} />
      <Select value={form.role} onValueChange={(v) => setForm({ ...form, role: v })}>
        <SelectTrigger><SelectValue placeholder="Role" /></SelectTrigger>
        <SelectContent>
          <SelectItem value="parent">Parent</SelectItem>
          <SelectItem value="player">Player</SelectItem>
        </SelectContent>
      </Select>
      <Input placeholder="Name optional" value={form.name} onChange={(e) => setForm({ ...form, name: e.target.value })} />
      <Input placeholder="Email" value={form.email} onChange={(e) => setForm({ ...form, email: e.target.value })} />
      <Input placeholder="Password" type="password" value={form.password} onChange={(e) => setForm({ ...form, password: e.target.value })} />
      <Button onClick={() => acceptCode.mutate()} disabled={acceptCode.isPending}>Join</Button>
    </div>
  );
}
```

---

## SendGrid template copy suggestion
```html
<!doctype html>
<html>
  <body style="font-family: Inter, Arial, sans-serif;">
    <div style="max-width:640px;margin:0 auto;padding:24px">
      <img src="{{tenant_logo_url}}" alt="{{tenant_name}}" style="height:40px;" />
      <h2>You are invited to join {{tenant_name}} on PlayHQ</h2>
      <p>{{inviter_name}} invited you to join as a {{role}}.</p>
      {{#if note}}
        <blockquote style="border-left:4px solid #ddd;padding:8px 12px;color:#555;">{{note}}</blockquote>
      {{/if}}
      <p>Click the button below to accept your invitation.</p>
      <p><a href="{{join_link}}" style="display:inline-block;padding:12px 16px;background:#111;color:#fff;text-decoration:none;border-radius:6px">Accept invitation</a></p>
      {{#if join_code}}
        <p>Or go to PlayHQ and use this tenant code: <strong>{{join_code}}</strong></p>
      {{/if}}
      <p>{{expiration_text}}</p>
      <p>If you did not expect this, you can ignore this email.</p>
      <p>Need help Contact support at support@playhq.com</p>
    </div>
  </body>
</html>
```

---

## .env expectations
```env
SENDGRID_API_KEY=...
SENDGRID_TEMPLATE_INVITE=d-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
SENDGRID_FROM_NAME=PlayHQ
SENDGRID_FROM_ADDRESS=no-reply@playhq.com
APP_URL=https://app.playhq.com
VITE_API_URL=https://api.playhq.com
```

---

## Notes
- Replace fake password hashing with your real auth utility
- If you already have user membership tables, remove the duplicate and adjust imports
- Add real rate limiting middleware where marked if you have one
- Secure the SendGrid webhook with their signature verification if you prefer
- Update your router and nav to link to Admin Invitations and public Join
- Add guards on any existing non admin signup route to force use of invite token or tenant code
