PASTE THIS EXACTLY INTO REPLIT ASSISTANT AS ONE TASK. DO EVERYTHING IN ORDER. UPDATE FILES IN PLACE. CREATE MISSING PATHS.

Objective
Deliver three owner-level features:

1. **Company KPIs block** (MRR/ARR, NRR/GRR, A/R aging, churn risk) with working API endpoints and charts.
2. **Tenant Profile Drawer** (health score + usage vs plan + invoices) available from Tenants table.
3. **Dunning Dashboard** (failed → in-retry → recovered) with one-click retry.
   All amounts are currency-safe; all endpoints accept `from`, `to` and paginate where applicable.

Packages

```
npm i zod @tanstack/react-query @tanstack/react-table recharts
```

Conventions & helpers

* Amounts stored as **cents**; render via `formatCurrency(cents)` helper.
* Dates in ISO; server parses with `new Date(value)`; client always `encodeURIComponent`.
* Add `server/lib/currency.ts`:

```ts
export const toCents = (n: number) => Math.round(n * 100);
export const fromCents = (c: number) => (c ?? 0) / 100;
export const sumCents = (arr: number[]) => arr.reduce((a,b)=>a+(b||0),0);
```

* Add `src/lib/api.ts` (if not present) with safe `get/post/patch` wrapper (uses `fetch(url, init)`; never `fetch(method,url)`).

───────────────────────────────────────────────────────────────────────────────
A) DATABASE: add minimal tables (migrations or schema files)

1. Platform billing (tenants → us)

* Table `tenant_invoices`

  * `id` PK, `tenant_id` FK, `period_start` ts, `period_end` ts
  * `subtotal_cents` int, `tax_cents` int, `total_cents` int
  * `status` enum('draft','open','paid','uncollectible','void')
  * `due_at` ts, `paid_at` ts, `currency` text default 'USD', `created_at` ts default now
* Table `tenant_invoice_lines`

  * `id` PK, `invoice_id` FK, `type` text, `qty` int, `unit_price_cents` int, `amount_cents` int
* Table `dunning_events`

  * `id` PK, `invoice_id` FK, `attempt_no` int, `status` enum('failed','retry\_scheduled','retrying','recovered','uncollectible')
  * `gateway_txn_id` text, `reason` text, `created_at` ts default now

2. Plans & usage

* Table `plan_catalog` — `code` PK, `name`, `price_cents`, `limits` JSONB
* Table `tenant_plan_assignments` — `tenant_id` FK, `plan_code` FK, `since` ts, `until` ts null
* Table `tenant_usage_daily` — `tenant_id`, `date` (date), counters JSONB (`players`, `sessions`, `emails`, `sms`, `storage_mb`, `api_calls`), `created_at` ts

If some already exist, extend them; otherwise create these.

Seed (optional dev only): add 3 invoices per tenant across last 3 months, some failed; create 30 days of `tenant_usage_daily` counters.

───────────────────────────────────────────────────────────────────────────────
B) SERVER: validation schemas & routes

Create `server/validators/kpi.ts`

```ts
import { z } from 'zod';
export const rangeSchema = z.object({
  from: z.string().datetime().optional(),
  to: z.string().datetime().optional(),
  page: z.coerce.number().int().min(1).default(1),
  pageSize: z.coerce.number().int().min(1).max(200).default(25),
});
```

1. Company KPIs endpoints — `server/controllers/superAdmin/kpi.ts`

```ts
import { Request, Response } from 'express';
import { sql } from 'drizzle-orm';
import { rangeSchema } from '../../validators/kpi';
import { fromCents } from '../../lib/currency';
// tables: tenant_invoices, tenant_invoice_lines, tenant_plan_assignments, plan_catalog

// Helper for date predicates
const dtWhere = (col: any, from?: string, to?: string) => sql`
  ${from ? sql`${col} >= ${new Date(from)}` : sql``}
  ${to   ? sql`${from? sql` and `: sql``}${col} <= ${new Date(to)}` : sql``}
`;

export async function companyOverview(req: Request, res: Response) {
  const { from, to } = rangeSchema.pick({from:true, to:true}).parse(req.query);

  // MRR (sum of current month recurring invoice lines)
  const mrr = await req.db.execute(sql`
    select coalesce(sum(il.amount_cents),0) as cents
    from tenant_invoice_lines il
    join tenant_invoices i on i.id = il.invoice_id
    where i.status in ('open','paid') and il.type = 'recurring'
      ${dtWhere(sql`i.period_start`, from, to)}
  `).then(r => Number((r as any).rows[0]?.cents || 0));

  // ARR = MRR * 12
  const arr = mrr * 12;

  // Gross retention (GRR) & Net retention (NRR) month-over-month
  // Define base as revenue from tenants active last month vs this month
  const nrrGrr = await req.db.execute(sql`
    with last as (
      select tenant_id, coalesce(sum(total_cents),0) as rev
      from tenant_invoices where status='paid'
        and date_trunc('month', paid_at) = date_trunc('month', now()) - interval '1 month'
      group by tenant_id
    ), curr as (
      select tenant_id, coalesce(sum(total_cents),0) as rev
      from tenant_invoices where status='paid'
        and date_trunc('month', paid_at) = date_trunc('month', now())
      group by tenant_id
    )
    select
      coalesce((select sum(c.rev)::float from curr c join last l using(tenant_id)),0) as curr_from_last,
      coalesce((select sum(l.rev)::float from last l),0) as last_total,
      coalesce((select sum(c.rev)::float from curr c),0) as curr_total
  `).then(r => (r as any).rows[0] || { curr_from_last:0, last_total:0, curr_total:0 });

  const grr = nrrGrr.last_total ? (nrrGrr.curr_from_last / nrrGrr.last_total) : 0;
  const nrr = nrrGrr.last_total ? (nrrGrr.curr_total     / nrrGrr.last_total) : 0;

  // A/R aging buckets on open/uncollectible invoices
  const aging = await req.db.execute(sql`
    select
      sum(case when now()-due_at <= interval '30 days' then total_cents else 0 end) as b0_30,
      sum(case when now()-due_at >  interval '30 days' and now()-due_at <= interval '60 days' then total_cents else 0 end) as b31_60,
      sum(case when now()-due_at >  interval '60 days' and now()-due_at <= interval '90 days' then total_cents else 0 end) as b61_90,
      sum(case when now()-due_at >  interval '90 days' then total_cents else 0 end) as b90p
    from tenant_invoices
    where status in ('open','uncollectible')
  `).then(r => (r as any).rows[0] ?? {});

  // Churn risk candidates: tenants with no paid invoice in 30d or with 2+ failed dunning events
  const churnRisk = await req.db.execute(sql`
    with last_paid as (
      select tenant_id, max(paid_at) as last_paid_at
      from tenant_invoices where status='paid'
      group by tenant_id
    ), failed as (
      select i.tenant_id, count(*) as failures
      from dunning_events d join tenant_invoices i on i.id = d.invoice_id
      where d.status in ('failed','retrying','retry_scheduled')
      group by i.tenant_id
    )
    select t.id, t.name, coalesce(lp.last_paid_at,'1970-01-01') as last_paid_at, coalesce(f.failures,0) as failures
    from tenants t
    left join last_paid lp on lp.tenant_id = t.id
    left join failed f on f.tenant_id = t.id
    where (lp.last_paid_at is null or lp.last_paid_at < now() - interval '30 days')
       or coalesce(f.failures,0) >= 2
    order by lp.last_paid_at nulls first, f.failures desc
    limit 20
  `).then(r => (r as any).rows);

  res.json({
    mrr: fromCents(mrr),
    arr: fromCents(arr),
    nrr: Number(nrr.toFixed(3)),
    grr: Number(grr.toFixed(3)),
    arAging: {
      b0_30: fromCents(Number(aging.b0_30||0)),
      b31_60: fromCents(Number(aging.b31_60||0)),
      b61_90: fromCents(Number(aging.b61_90||0)),
      b90p: fromCents(Number(aging.b90p||0)),
    },
    churnRisk: churnRisk.map((r:any)=>({ tenantId:r.id, tenantName:r.name, lastPaidAt:r.last_paid_at, failures:r.failures })),
  });
}

// Series for charts (month granularity)
export async function kpiSeries(req: Request, res: Response) {
  const { from, to } = rangeSchema.pick({from:true, to:true}).parse(req.query);
  const series = await req.db.execute(sql`
    with inv as (
      select date_trunc('month', paid_at) as m, sum(total_cents) as paid_cents
      from tenant_invoices
      where status='paid' ${dtWhere(sql`paid_at`, from, to)}
      group by 1
    )
    select m, paid_cents from inv order by m asc
  `).then(r => (r as any).rows.map((x:any)=>({ date:x.m, revenue: fromCents(Number(x.paid_cents||0)) })));
  res.json({ series });
}
```

2. Tenant Profile & usage — `server/controllers/superAdmin/tenantProfile.ts`

```ts
import { Request, Response } from 'express';
import { sql } from 'drizzle-orm';
import { rangeSchema } from '../../validators/kpi';
import { fromCents } from '../../lib/currency';

// naive health score (0-100)
function healthScore(input: {usagePct:number; failedDunning:number; noPaymentDays:number}) {
  let score = 100;
  score -= Math.max(0, 40 - Math.round(input.usagePct*40));             // low usage penalty
  score -= Math.min(30, input.failedDunning*10);                         // each failure -10 up to -30
  score -= Math.min(30, Math.floor(input.noPaymentDays/15)*10);          // -10 per 15 days without payment
  return Math.max(0, Math.min(100, score));
}

export async function profile(req: Request, res: Response) {
  const id = req.params.id;
  const { from, to } = rangeSchema.pick({from:true, to:true}).parse(req.query);

  const plan = await req.db.execute(sql`
    select p.code, p.name, p.price_cents, p.limits
    from tenant_plan_assignments tpa join plan_catalog p on p.code = tpa.plan_code
    where tpa.tenant_id = ${id} and (tpa.until is null or tpa.until > now())
    order by tpa.since desc limit 1
  `).then(r => (r as any).rows[0] || null);

  const usage = await req.db.execute(sql`
    select
      coalesce(sum((counters->>'players')::int),0) as players,
      coalesce(sum((counters->>'sessions')::int),0) as sessions,
      coalesce(sum((counters->>'emails')::int),0) as emails,
      coalesce(sum((counters->>'sms')::int),0) as sms,
      coalesce(sum((counters->>'api_calls')::int),0) as api_calls
    from tenant_usage_daily
    where tenant_id=${id}
      ${from ? sql` and date >= ${new Date(from)}` : sql``}
      ${to   ? sql` and date <= ${new Date(to)}`   : sql``}
  `).then(r => (r as any).rows[0] || {});

  const lastPaid = await req.db.execute(sql`
    select max(paid_at) as last_paid from tenant_invoices where tenant_id=${id} and status='paid'
  `).then(r => (r as any).rows[0]?.last_paid);

  const failedDunning = await req.db.execute(sql`
    select count(*) as c from dunning_events d join tenant_invoices i on i.id = d.invoice_id
    where i.tenant_id=${id} and d.status in ('failed','retrying','retry_scheduled')
  `).then(r => Number((r as any).rows[0]?.c||0));

  const noPayDays = lastPaid ? Math.floor((Date.now()-new Date(lastPaid).getTime())/86400000) : 999;
  const usagePct = plan?.limits ? Math.min(1,
    ((usage.players / (plan.limits.players||1)) +
     (usage.sessions / (plan.limits.sessions||1)) ) / 2
  ) : 0.3;

  const score = healthScore({usagePct, failedDunning, noPaymentDays: noPayDays});

  // recent invoices
  const invoices = await req.db.execute(sql`
    select id, total_cents, status, due_at, paid_at
    from tenant_invoices where tenant_id=${id}
    order by created_at desc limit 12
  `).then(r => (r as any).rows.map((x:any)=>({ ...x, total: fromCents(Number(x.total_cents||0)) })));

  res.json({
    plan, usage, lastPaidAt:lastPaid, healthScore:score, healthDrivers:{usagePct, failedDunning, noPayDays},
    invoices,
  });
}
```

3. Dunning dashboard — `server/controllers/superAdmin/dunning.ts`

```ts
import { Request, Response } from 'express';
import { sql } from 'drizzle-orm';
import { rangeSchema } from '../../validators/kpi';

export async function list(req: Request, res: Response) {
  const { page, pageSize, from, to } = rangeSchema.parse(req.query);
  const offset = (page-1)*pageSize;
  const rows = await req.db.execute(sql`
    select d.id, d.status, d.attempt_no, d.reason, d.created_at,
           i.id as invoice_id, i.tenant_id, t.name as tenant_name, i.total_cents, i.status as invoice_status
    from dunning_events d
    join tenant_invoices i on i.id = d.invoice_id
    join tenants t on t.id = i.tenant_id
    where 1=1
      ${from ? sql` and d.created_at >= ${new Date(from)}` : sql``}
      ${to   ? sql` and d.created_at <= ${new Date(to)}`   : sql``}
    order by d.created_at desc
    limit ${pageSize} offset ${offset}
  `).then(r => (r as any).rows);

  const total = await req.db.execute(sql`select count(*)::int as c from dunning_events`).then(r => Number((r as any).rows[0].c));
  res.json({ rows, page, pageSize, totalRows: total });
}

// NOTE: this delegates to payment gateway adapter (Stripe/Braintree)
export async function retry(req: Request, res: Response) {
  const { id } = req.params; // dunning event id OR invoice id
  // fetch invoice id
  const row = await req.db.execute(sql`
    select i.id, i.tenant_id, i.total_cents from dunning_events d join tenant_invoices i on i.id=d.invoice_id
    where d.id=${id} limit 1
  `).then(r => (r as any).rows[0]);
  if (!row) return res.status(404).json({error:'not_found'});

  // TODO: call gateway charge again using stored payment method (stub success)
  const ok = true;

  if (ok) {
    await req.db.execute(sql`insert into dunning_events (invoice_id, attempt_no, status, reason) values (${row.id}, 99, 'recovered', 'manual_retry')`);
    return res.json({ ok:true, status:'recovered' });
  } else {
    await req.db.execute(sql`insert into dunning_events (invoice_id, attempt_no, status, reason) values (${row.id}, 99, 'failed', 'manual_retry_failed')`);
    return res.json({ ok:false, status:'failed' });
  }
}
```

4. Wire routes — `server/routes/superAdmin.ts`
   Append:

```ts
import * as kpi from '../controllers/superAdmin/kpi';
import * as tenantProfile from '../controllers/superAdmin/tenantProfile';
import * as dunning from '../controllers/superAdmin/dunning';

r.get('/kpi/company/overview', kpi.companyOverview);
r.get('/kpi/company/series',    kpi.kpiSeries);

r.get('/tenants/:id/profile',   tenantProfile.profile);

r.get('/billing/dunning',       dunning.list);
r.post('/billing/dunning/:id/retry', dunning.retry);
```

───────────────────────────────────────────────────────────────────────────────
C) CLIENT: UI & data wiring

Common bits

* Add to `src/lib/format.ts`:

```ts
export const fmtMoney = (n:number) => n.toLocaleString(undefined, {style:'currency', currency:'USD'});
export const fmtPct   = (n:number) => `${Math.round(n*100)}%`;
export const fmtDate  = (d:string|Date) => new Date(d).toLocaleDateString();
```

* Ensure `src/components/super-admin/ui/StatCard.tsx` exists (title, value, subtext).

1. Company KPIs block (Overview + Series)

* Update **Company → Overview** page (`src/routes/super-admin/Overview.tsx`)
  Under the existing cards, add a **Company KPIs** section that fetches `/api/super-admin/kpi/company/overview?from=&to=` and renders:

  * Cards: **MRR**, **ARR**, **NRR**, **GRR** (show as %).
  * A/R aging mini-bars: 0–30, 31–60, 61–90, 90+ buckets (sum + badge).
  * **Churn risk** list (tenant name, last paid, failures) with a “view profile” link (opens Tenant Drawer; see next).
* In **Analytics** page (company lane), add a “Revenue Series (Paid Invoices)” chart sourced from `/api/super-admin/kpi/company/series?from=&to=`.

2. Tenant Profile Drawer (from Tenants table)

* Create `src/components/super-admin/TenantProfileDrawer.tsx`

  * Props: `tenantId`, `open`, `onOpenChange`.
  * Fetch `/api/super-admin/tenants/:id/profile?from=&to=` with React Query.
  * Layout (tabs inside drawer):

    * **Summary**: Plan (name/price), Health Score (big number) + chips for drivers (usage %, failed dunning, days since last payment), Last 3 invoices (status chip).
    * **Usage vs Plan**: progress bars computed with `usage` vs `plan.limits` (players, sessions, emails/SMS/API).
    * **Invoices**: table of recent invoices (status, due, paid, amount).
  * Action buttons: **Impersonate** (if you already have), **Freeze Tenant** (placeholder).
* Update `src/routes/super-admin/Tenants.tsx`:

  * Add **Plan** column (current plan code).
  * On row click or action button, open the **TenantProfileDrawer**.

3. Dunning Dashboard (billing → collections)

* New route `src/routes/super-admin/Dunning.tsx` under Company group or within Platform Billing as a sub-tab:

  * Shared filters: date range + quick status chips (All / Failed / Retrying / Recovered).
  * Table columns: Tenant, Invoice#, Attempt#, Status, Reason, Amount, Event Date, Actions.
  * Fetch `/api/super-admin/billing/dunning?from=&to=&page=&pageSize=`; server returns `{rows,page,pageSize,totalRows}`.
  * Row action **Retry charge** → POST `/api/super-admin/billing/dunning/:id/retry` → optimistic toast (“Retry queued”) → refetch.
  * KPIs header strip: “Failed today”, “In retry”, “Recovered this month”, “Uncollectible > 90d” (can compute client-side from rows as a first pass; later server aggregates).
* Navigation: add **Dunning** as a button or tab inside **Platform Billing** page.

───────────────────────────────────────────────────────────────────────────────
D) ACCEPTANCE CRITERIA (verify manually)

Company KPIs

* Changing date range updates MRR/ARR, NRR/GRR, A/R aging, and Churn Risk list.
* Series endpoint drives a monthly line chart of paid revenue.

Tenant Profile Drawer

* Clicking a tenant opens a drawer with plan, health, drivers, usage bars, and last invoices.
* Health score shows 0–100 and driver chips update correctly when data changes.

Dunning Dashboard

* Table paginates. Status/Date filters work.
* Retry action returns success response and inserts a “recovered” dunning event (stub OK for now).
* Header KPIs reflect the current dataset.

Technical

* All server params validated with Zod; bad params return 400 with message.
* All amounts rendered via `fmtMoney(fromCents)` or `fmtMoney(number)` depending on endpoint.
* No NaN/undefined in cards; empty states show friendly messages.
* All new endpoints behind super-admin auth.

───────────────────────────────────────────────────────────────────────────────
E) NOTES & NEXT STEPS (leave TODOs in code)

* The health score is v1 and intentionally simple; leave a TODO to add feature adoption + support SLA into the score.
* Dunning `retry` uses a stub gateway call; leave a TODO to wire Stripe/Braintree adapters.
* If `tenant_usage_daily` doesn’t exist, include a TODO to run a nightly job that rolls up usage from source tables (players, sessions, emails, sms, api logs).

When finished, post a short summary of files changed and screenshots of:
(1) Company Overview with KPI block populated, (2) Tenant Profile Drawer open, (3) Dunning Dashboard with a successful retry.
