Implement in‑app refunds & voids (Braintree + Stripe) and expose per‑player session history
Goal

From our Admin > Players table, the Sessions count for each player becomes clickable. Clicking opens a scrollable dropdown/accordion listing every session the player participated in, with payment details and actions:

Show: session title/date/time, location, capacity, signup status, processor (Braintree/Stripe), amount, currency, payment status, payment/charge ID, created/settled timestamps, and refund/void status if any.

Actions (permission: admin/super admin only):

Void (when Braintree transaction is authorized or submitted_for_settlement; Stripe authorized or uncaptured)

Refund (full or partial) when transaction is settled/settling (Braintree) or captured (Stripe)

Confirm modal with amount (default full, allow partial for Refund only), reason (optional), and irreversible warning.

What needs to happen (end‑to‑end)

1) Data model & migrations
Add a durable place to store processor metadata and map it to our domain objects.

Table: payments

id (uuid, pk)

player_id (fk -> players)

parent_id (nullable fk -> parents)

session_id (fk -> futsal_sessions)

processor enum(braintree,stripe)

processor_payment_id (text) // Braintree transaction.id or Stripe payment_intent/charge id

processor_customer_id (text) // optional, bt customer id / stripe customer id

amount_cents (int)

currency (text, default 'USD')

status enum(authorized,submitted_for_settlement,settling,settled,voided,refunded,partial_refunded,failed)

captured_at (timestamp, nullable)

voided_at (timestamp, nullable)

refunded_at (timestamp, nullable)

refund_amount_cents (int, default 0)

meta (jsonb) // any gateway response payloads

tenant_id (fk)

created_at, updated_at

Table: refunds

id (uuid, pk)

payment_id (fk -> payments)

processor_refund_id (text) // Braintree refund transaction id or Stripe refund id

amount_cents (int)

reason (text, nullable)

initiated_by_user_id (fk -> users)

status enum(pending,succeeded,failed)

processor_response (jsonb)

created_at, updated_at

Ensure multi‑tenant scoping (tenant_id) and indexes on (player_id,session_id), and (processor,processor_payment_id).

2) Capturing IDs both ways during checkout
When creating/confirming a payment:

Braintree: store transaction.id, transaction.status, amount, currency, and customer.id (create/update customer using the parent or player name; pass our player’s full name in customer.firstName/lastName or customFields.playerName if configured). Save to payments.

Stripe: store payment_intent.id, and the final charge.id (top‑level successful one). Persist status and amounts to payments.

Attach to sessions:

Link the created payments.id to the signups (or booking) record so we can reverse‑navigate on the player.

3) Webhooks to keep statuses honest
Create webhook handlers and secure them (signatures, secrets per tenant):

Braintree:

Listen for transaction_disbursed, transaction_settled, transaction_settlement_declined, transaction_voided, dispute_*, disbursement_exception, disbursement.

Update payments.status accordingly (settled, voided, etc.), fill captured_at, voided_at.

Stripe:

Listen for payment_intent.succeeded, charge.refunded, charge.refund.updated, charge.captured, charge.dispute.*.

Update payments.status and amounts; create refunds rows on refund events.

Add idempotency by checking processor_payment_id/processor_refund_id before insert/update.

4) Service layer: Refunds & Voids
Create a unified service that abstracts the gateway differences.

POST /api/admin/payments/:paymentId/void

Verify tenant scoping, role.

Load payments row → If processor='braintree' and status in (authorized,submitted_for_settlement) call gateway.transaction.void(id).

If processor='stripe' and uncaptured PI/charge → use stripe.refunds.create({charge, amount: 0}) or stripe.paymentIntents.cancel when appropriate. (Note: Stripe void is effectively “refund before capture” or cancel uncaptured intent.)

Update payments.status='voided', set voided_at, store response in meta.

POST /api/admin/payments/:paymentId/refund

Body: { amountCents?: number, reason?: string }

Validate status is refundable (Braintree: settled/settling; Stripe: succeeded/captured).

Braintree: gateway.transaction.refund(transactionId, amount) (omit amount for full).

Stripe: stripe.refunds.create({ charge, amount, reason }).

Insert refunds row; set payments.status to refunded or partial_refunded (if amount < original), set refund_amount_cents and refunded_at; store processor refund id/response.

Errors:

Return structured error { code, message, details } from gateway responses; map common codes (already_refunded, not_settled, insufficient_funds, etc.).

5) UI: Players > Sessions column → dropdown history
In Admin > Players list, make the Sessions number a button/badge.

On click: open a drawer/accordion (max‑height with internal scroll on mobile) listing each session row:

Layout per row:

Left: Session Title · Date · Time · Location (location remains the Google Maps deep link).

Middle: Processor, Amount, Currency, Status badge (color‑coded), Payment/Charge ID (copyable, shortened with tooltip).

Right: Action menu (…):

If voidable: Void (danger)

If refundable: Refund (primary). Opens modal: amount input (prefill full), reason textarea, confirm button. On confirm, disable and show spinner.

Below the payment details, show tiny timeline badges if refunded/voided: Refunded $X on Aug 11, 2:17 PM (ID: re_...), Voided at ....

Confirmation modals:

Void modal: Explain that it cancels the transaction before settlement.

Refund modal: Explain settlement must have occurred; can be partial; show remaining refundable balance.

Toasts:

On success, show “Refund of $X submitted” or “Transaction voided”.

On failure, show detailed error message from API.

Audit trail:

After action, append an entry to recent_activity and show it in Admin Dashboard > Recent Activity (e.g., “Refund issued for Harper Brind · $10.00 · Session: U10 Training · by Atticus”).

6) Permissions & safety
Only admin and super admin may void/refund.

Confirm tenant boundaries on every API call.

Validate that payment.player_id belongs to the player being viewed.

Add server‑side limits: partial refund must be >0 and <= (amount - prior refunds).

7) Braintree specifics
Ensure SDK is initialized with merchant credentials per tenant (from integrations table).

When creating transactions, populate:

customer.firstName/lastName or customerId if already created,

transactionOptions.submitForSettlement=true (or leave authorized based on flow),

customFields (if configured) like tenant, playerId, sessionId for traceability.

For void eligibility: use transaction status or rely on Braintree to error if not voidable; map error to UI nicely.

8) Stripe specifics
Persist both payment_intent and top‑level charge id (we’ll refund by charge).

If “voiding” before capture, cancel the PaymentIntent or refund an uncaptured/authorized charge (no effect if not captured).

Map Stripe’s statuses to our payments.status.

9) API surfaces
Create/extend these endpoints (typescript/Express examples):

GET /api/admin/players/:playerId/sessions-with-payments?limit=50&cursor=...

Returns list of sessions joined by player with embedded payment object (or null if unpaid).

POST /api/admin/payments/:paymentId/void

POST /api/admin/payments/:paymentId/refund

POST /api/webhooks/braintree

POST /api/webhooks/stripe

Ensure the existing Players page calls GET ...sessions-with-payments when expanding the Sessions badge.

10) UI polish
Status chips (consistent across app):

authorized (gray), submitted_for_settlement (blue), settling (blue), settled (green), voided (red), refunded (purple), partial_refunded (purple‑outline), failed (red‑outline).

Copy buttons next to processor IDs.

Guard rails: if gateway credentials missing for tenant, disable actions with tooltip “Payments integration not connected”.

11) Error UX for upload/long ops (reuse pattern)
Use our standardized <ErrorToast> that:

Shows processor error code + friendly message.

Stays visible for 20 seconds on refund/void failures; dismissible; logs to console with correlation id.

12) Testing checklist
Seed one Braintree and one Stripe payment for a test player & session (authorized, submitted, settled).

Test:

Void authorized (BT), ensure BT dashboard shows Voided and our row updates via webhook.

Refund settled (BT) full and partial; verify refund rows are created; status transitions correct.

Stripe: refund charge; verify webhooks update our payments and refunds.

Multi‑tenant: attempt cross‑tenant refund → 403.

UI: mobile drawer behavior and long lists performance.

13) Documentation
Add a short Refunds & Voids section to production.md:

Eligibility matrix (void vs refund, BT vs Stripe).

Where to find actions (Players → Sessions dropdown).

Audit trail + reconciliation notes.

Deliverables

DB migration files (Drizzle).

New/updated server routes + gateway services (Braintree + Stripe).

Webhook handlers with signature verification and idempotency.

Players page UI changes (sessions badge, drawer, modals).

Activity log entries.

Tests (unit for services, integration for routes).

Docs updates.

Notes

Keep the flow identical for Stripe and Braintree from the user’s perspective; we abstract differences server‑side.

For Braintree, if we choose to always submitForSettlement=true, void window is short—document that; otherwise, allow authorized‑only for delayed capture programs (future setting).