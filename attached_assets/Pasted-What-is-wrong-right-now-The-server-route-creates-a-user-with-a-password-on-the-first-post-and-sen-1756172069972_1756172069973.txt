What is wrong right now

• The server route creates a user with a password on the first post and sends a welcome email
• There is no tenant created for the new client
• There is no verification token or email_verified status, so links and first password set can not work
• SendGrid helper exists but does not send a verification link that points back to a set_password page

Plan of record

Keep your current form for Organization Name, Contact Name, Email, Country, State, City

On submit, call a new route that creates a tenant and a pending admin user, generates a token, and emails a verify link

Click from the email opens a set_password page that posts a new password with the token

Server validates the token, marks the user verified and active, saves the password, signs the user in, and routes to the client dashboard

Drizzle schema additions

shared/schema.ts

import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

export const tenants = pgTable("tenants", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: text("name").notNull(),
  plan_tier: text("plan_tier").notNull().default("Free"),
  created_at: timestamp("created_at").defaultNow(),
});

export const users = pgTable("users", {
  id: uuid("id").defaultRandom().primaryKey(),
  email: text("email").notNull().unique(),
  password_hash: text("password_hash"),            // null until first set
  role: text("role").notNull().default("admin"),
  tenant_id: uuid("tenant_id").references(() => tenants.id),
  status: text("status").notNull().default("PENDING_VERIFY"),
  email_verified_at: timestamp("email_verified_at"),
  created_at: timestamp("created_at").defaultNow(),
});

export const email_verification_tokens = pgTable("email_verification_tokens", {
  id: uuid("id").defaultRandom().primaryKey(),
  user_id: uuid("user_id").references(() => users.id).notNull(),
  token_hash: text("token_hash").notNull(),
  expires_at: timestamp("expires_at").notNull(),
  used_at: timestamp("used_at"),
  created_at: timestamp("created_at").defaultNow(),
});

export const tenantRelations = relations(tenants, ({ many }) => ({
  users: many(users),
}));


Run your drizzle kit generate and push so these tables exist.

SendGrid helper

server/services/sendGrid.ts

import sg from "@sendgrid/mail";

export function initEmail() {
  const key = process.env.SENDGRID_API_KEY;
  if (!key) throw new Error("SENDGRID_API_KEY missing");
  sg.setApiKey(key);
}

type MailInput = { to: string; subject: string; html: string; text?: string };

export async function sendEmail({ to, subject, html, text }: MailInput) {
  const from_email = process.env.EMAIL_FROM_ADDRESS as string;
  const from_name = process.env.EMAIL_FROM_NAME || "PlayHQ";
  if (!from_email) throw new Error("EMAIL_FROM_ADDRESS missing");

  await sg.send({
    to,
    from: { email: from_email, name: from_name },
    subject,
    html,
    text: text ?? "",
  });
}

Auth routes

Create a new router and remove the old direct password signup. Keep your existing import style for db and schema.

server/routes/auth.ts

import { Router } from "express";
import crypto from "crypto";
import bcrypt from "bcryptjs";
import { db } from "../db";
import { tenants, users, email_verification_tokens } from "@shared/schema";
import { eq, and, isNull, gt } from "drizzle-orm";
import { sendEmail } from "../services/sendGrid";

export const authRouter = Router();

function newToken() {
  const raw = crypto.randomBytes(32).toString("base64url");
  const hash = crypto.createHash("sha256").update(raw).digest("hex");
  return { raw, hash };
}

// client self signup for admins
authRouter.post("/signup_client", async (req, res) => {
  const { organization_name, contact_name, email, country, state, city } = req.body;
  if (!organization_name || !contact_name || !email) {
    return res.status(400).json({ ok: false, error: "Missing fields" });
  }

  // create tenant and user
  const [tenant] = await db.insert(tenants).values({
    name: organization_name,
    plan_tier: "Free",
  }).returning();

  const [user] = await db.insert(users).values({
    email: String(email).toLowerCase(),
    role: "admin",
    tenant_id: tenant.id,
    status: "PENDING_VERIFY",
  }).returning();

  // create token
  const { raw, hash } = newToken();
  const expires = new Date(Date.now() + 1000 * 60 * 60 * 48);
  await db.insert(email_verification_tokens).values({
    user_id: user.id,
    token_hash: hash,
    expires_at: expires,
  });

  // send email
  const app_url = process.env.APP_URL as string;
  const link = `${app_url}/set_password?token=${encodeURIComponent(raw)}`;
  const html = `
    <p>Hi ${contact_name},</p>
    <p>Finish setting up your PlayHQ account.</p>
    <p><a href="${link}">Verify and continue</a></p>
    <p>If you did not request this, ignore this message.</p>
  `;
  await sendEmail({
    to: user.email,
    subject: "Verify your email to continue",
    html,
    text: `Open this link to continue: ${link}`,
  });

  return res.json({ ok: true });
});

// optional link precheck
authRouter.get("/verify_email", async (req, res) => {
  const token = String(req.query.token || "");
  const token_hash = crypto.createHash("sha256").update(token).digest("hex");
  const [record] = await db.select().from(email_verification_tokens).where(
    and(
      eq(email_verification_tokens.token_hash, token_hash),
      isNull(email_verification_tokens.used_at),
      gt(email_verification_tokens.expires_at, new Date())
    )
  );
  if (!record) return res.status(400).json({ ok: false, error: "Invalid or expired link" });
  return res.json({ ok: true });
});

// set first password
authRouter.post("/set_password", async (req, res) => {
  const { token, password } = req.body as { token: string; password: string };
  if (!token || !password) return res.status(400).json({ ok: false, error: "Missing fields" });
  if (password.length < 10) return res.status(400).json({ ok: false, error: "Password too weak" });

  const token_hash = crypto.createHash("sha256").update(token).digest("hex");

  const [record] = await db.select().from(email_verification_tokens).where(
    and(
      eq(email_verification_tokens.token_hash, token_hash),
      isNull(email_verification_tokens.used_at),
      gt(email_verification_tokens.expires_at, new Date())
    )
  );
  if (!record) return res.status(400).json({ ok: false, error: "Invalid or expired link" });

  const hash = await bcrypt.hash(password, 12);

  await db.transaction(async tx => {
    await tx.update(users)
      .set({ password_hash: hash, status: "ACTIVE", email_verified_at: new Date() })
      .where(eq(users.id, record.user_id));
    await tx.update(email_verification_tokens)
      .set({ used_at: new Date() })
      .where(eq(email_verification_tokens.id, record.id));
  });

  // issue cookie or jwt here using your existing method
  // res.cookie("session", jwt, { httpOnly: true, sameSite: "lax", secure: true });

  return res.json({ ok: true, redirect: "/client" });
});

// resend verify
authRouter.post("/resend_verification", async (req, res) => {
  const { email } = req.body as { email?: string };
  if (!email) return res.json({ ok: true });

  const [user] = await db.select().from(users).where(eq(users.email, String(email).toLowerCase()));
  if (!user || user.email_verified_at) return res.json({ ok: true });

  const { raw, hash } = newToken();
  const expires = new Date(Date.now() + 1000 * 60 * 60 * 48);
  await db.insert(email_verification_tokens).values({
    user_id: user.id,
    token_hash: hash,
    expires_at: expires,
  });

  const app_url = process.env.APP_URL as string;
  const link = `${app_url}/set_password?token=${encodeURIComponent(raw)}`;

  await sendEmail({
    to: user.email,
    subject: "Verify your email to continue",
    html: `<p>Continue your setup <a href="${link}">Verify and continue</a></p>`,
    text: `Open this link to continue ${link}`,
  });

  return res.json({ ok: true });
});


Mount this router and initialize email.

server/index.ts

import express from "express";
import cors from "cors";
import { initEmail } from "./services/sendGrid";
import { authRouter } from "./routes/auth";

initEmail();

const app = express();
app.use(express.json());
app.use(cors({ origin: process.env.APP_URL, credentials: true }));

app.use("/api/auth", authRouter);

app.listen(process.env.PORT || 3000, () => {
  console.log("server ready");
});

Frontend pages

After the form posts to signup_client, route to a verify screen with a resend button.

client/src/pages/VerifyEmailSent.tsx

import { useSearchParams } from "react-router-dom";
import { useState } from "react";

export default function VerifyEmailSent() {
  const [params] = useSearchParams();
  const email = params.get("email") || "";
  const [busy, setBusy] = useState(false);
  const [done, setDone] = useState(false);

  async function resend() {
    setBusy(true);
    await fetch(`${import.meta.env.VITE_API_URL}/api/auth/resend_verification`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email }),
    });
    setDone(true);
    setBusy(false);
  }

  return (
    <div className="max-w-md mx-auto p-6">
      <h1 className="text-xl font-semibold">Check your email</h1>
      <p>We sent a verification link to {email}</p>
      <button className="btn btn-primary mt-4" onClick={resend} disabled={busy || done}>
        {done ? "Sent" : busy ? "Sending..." : "Resend email"}
      </button>
    </div>
  );
}


Set password page that the email link opens

client/src/pages/SetPassword.tsx

import { useSearchParams, useNavigate } from "react-router-dom";
import { useEffect, useState } from "react";

export default function SetPassword() {
  const [params] = useSearchParams();
  const token = params.get("token") || "";
  const navigate = useNavigate();
  const [checking, setChecking] = useState(true);
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  useEffect(() => {
    fetch(`${import.meta.env.VITE_API_URL}/api/auth/verify_email?token=${encodeURIComponent(token)}`)
      .then(r => r.json())
      .then(j => { if (j.ok) setChecking(false); else setError("Invalid or expired link"); })
      .catch(() => setError("Invalid or expired link"));
  }, [token]);

  async function submit(e: React.FormEvent) {
    e.preventDefault();
    setError("");
    const r = await fetch(`${import.meta.env.VITE_API_URL}/api/auth/set_password`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include",
      body: JSON.stringify({ token, password }),
    });
    const j = await r.json();
    if (j.ok) navigate(j.redirect || "/client");
    else setError(j.error || "Could not set password");
  }

  if (checking && !error) return <div className="p-6">Checking link...</div>;
  if (error) return <div className="p-6 text-red-600">{error}</div>;

  return (
    <div className="max-w-md mx-auto p-6">
      <h1 className="text-xl font-semibold">Create your password</h1>
      <form onSubmit={submit} className="mt-4 space-y-4">
        <input
          type="password"
          className="input input-bordered w-full"
          placeholder="New password"
          value={password}
          onChange={e => setPassword(e.target.value)}
        />
        <button className="btn btn-primary w-full">Continue</button>
      </form>
    </div>
  );
}


Update your router to include these pages and make the signup form redirect to /verify_email_sent?email=<email> after a successful post to /api/auth/signup_client.

Env and SendGrid checklist

• Verify sender domain in SendGrid
• Ensure these vars exist in both server and Replit secrets
SENDGRID_API_KEY
EMAIL_FROM_NAME
EMAIL_FROM_ADDRESS
APP_URL for your front end base
VITE_API_URL on the client that points to the server base
• Confirm CORS uses APP_URL and that credentials are allowed if you set a cookie

Replace the old route

Delete or comment out server/routes/signup.ts that accepts a password at signup. Keep all auth in server/routes/auth.ts going forward.

Replit agent prompt

Copy this as a single message to your agent.

Goal
Finish admin signup with email verification and first password set. Use Drizzle and SendGrid. Remove the old direct password signup route.

Steps
1. Scan the repo for any files that handle signup or login and print the map. Remove server/routes/signup.ts if it creates a user with a password and a generic email.
2. Add the tables tenants, users fields password_hash status email_verified_at, and email_verification_tokens as shown in shared/schema.ts. Generate and run migrations.
3. Create server/services/sendGrid.ts with initEmail and sendEmail as shown. Call initEmail in server/index.ts at boot.
4. Create server/routes/auth.ts with four handlers
   POST /api/auth/signup_client
   GET  /api/auth/verify_email
   POST /api/auth/set_password
   POST /api/auth/resend_verification
   Implement token creation with 32 random bytes and sha256 hash. Token expires in 48 hours. Mark used_at when consumed. Use bcrypt at cost 12 for password hashing. On successful set_password, mark user ACTIVE and set email_verified_at, then sign in using the existing session method.
5. Client
   Add pages client/src/pages/VerifyEmailSent.tsx and client/src/pages/SetPassword.tsx as shown. After the current signup form posts to signup_client, navigate to /verify_email_sent?email=<email>. The email link should open /set_password?token=...
6. Config
   Ensure env variables SENDGRID_API_KEY EMAIL_FROM_NAME EMAIL_FROM_ADDRESS APP_URL and VITE_API_URL are present. Update CORS to allow APP_URL and credentials if cookies are used.
7. Cleanup
   Remove dead auth stubs and console spam. Add simple server side validation for inputs. Add basic rate limit on signup and resend.

Deliverables
   Updated schema and migrations
   sendGrid service helper
   auth router with four routes
   two client pages
   short README section that explains the flow and how to test