Multi-Tenant Authentication Flow Implementation with Clerk
Database Schema

Define a User and Tenant schema to support multi-tenancy. The User table links to Clerk users and optionally to a Tenant. For example, in PostgreSQL (or Prisma schema) format:

-- PostgreSQL schema example
CREATE TABLE tenants (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  invite_code TEXT NOT NULL UNIQUE,  -- using slug as invite code
  owner_user_id INTEGER,            -- FK to users(id) for the tenant owner
  CONSTRAINT fk_owner FOREIGN KEY(owner_user_id) REFERENCES users(id)
);

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  clerk_user_id TEXT NOT NULL UNIQUE,  -- maps to Clerk user ID
  tenant_id INTEGER,                   -- FK to tenant if member of a club
  role TEXT NOT NULL,                  -- e.g. 'coach' for club owners, 'member' for parents/players
  name TEXT,
  email TEXT,
  CONSTRAINT fk_tenant FOREIGN KEY(tenant_id) REFERENCES tenants(id)
);


(If using an ORM like Prisma, define equivalent models with relations and unique constraints.)

User: stores the Clerk user reference (clerk_user_id), an optional tenant_id (null if not yet in a club), a role (e.g. "coach" for club admins or "member" for regular users), and profile info like name and email.

Tenant: stores each club/organization with a unique slug (used as the invite code) and an invite_code (can mirror the slug for simplicity). Also track owner_user_id to know which user created the tenant (the club coach/owner). The slug and invite_code should be unique for each tenant to avoid collisions.

Ensure unique indexes on users.clerk_user_id, tenants.slug, and tenants.invite_code so duplicates are prevented at the database level. This schema will allow linking each user to at most one tenant (one club membership at a time).

Backend File Structure

Organize the implementation into clear files/modules. For example:

/lib/db.ts – Database client initialization (e.g. Prisma or another DB connector) and helper to connect to the User and Tenant tables.

/lib/clerk.ts – Clerk authentication helpers. For example, functions to get the current Clerk user ID from a request and to verify authentication on API routes.

/api/auth/clubSignup.ts – Coach/Club Sign-Up API. Endpoint to handle club owner registration. After the coach signs up via Clerk, this endpoint creates a new Tenant (club) and a corresponding User record linked to that tenant.

/api/auth/basicSignup.ts – Basic User Sign-Up API. Endpoint for parents/players. After a parent/player signs up via Clerk, this creates a User record with tenant_id = NULL (no club yet). This ensures every Clerk user has a corresponding app user record.

/api/tenant/join.ts – Join Tenant API. Endpoint to join an existing club. Accepts an invite code (club slug) and, if valid, updates the current User’s tenant_id to that tenant’s ID.

/api/me.ts (or similar, e.g. /api/auth/me) – Current User API. (Optional) Endpoint to fetch the logged-in user's profile (including tenant info) from the app database. The front-end uses this to check if the user has a tenant or not after login.

Each API endpoint should require authentication (the user must be logged in via Clerk) before proceeding. Use Clerk’s provided helpers or middleware to validate the session and get the Clerk userId. Below, we outline each file with example implementations.

Backend API Endpoint Implementations
/lib/db.ts – Database Client

Set up a database client instance (using your preferred library/ORM). For example, using Prisma:

// /lib/db.ts
import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient();


(If not using Prisma, export a configured DB client or query builder. The goal is to import prisma (or db) in other files to run queries.)

/lib/clerk.ts – Clerk Auth Helper

This module will provide utilities to access Clerk auth in API routes. For a Next.js API route environment with Clerk, you can use Clerk’s server functions:

// /lib/clerk.ts
import { getAuth } from "@clerk/nextjs/server";  // for Next.js API routes
// import { clerkClient } from "@clerk/clerk-sdk-node"; // (optional: to fetch Clerk user details if needed)

export function getClerkUserId(req: any): string | null {
  // Retrieves the Clerk-authenticated user ID from the request (returns null if not authed)
  const auth = getAuth(req);
  return auth.userId || null;
}

// Middleware-style helper to enforce auth on API routes
export function requireAuth(req: any, res: any): string {
  const auth = getAuth(req);
  if (!auth.userId) {
    res.status(401).json({ message: "Authentication required" });
    throw new Error("Authentication required");  // stop execution
  }
  return auth.userId;
}


If you’re using an Express-style server, you might use @clerk/express and middleware. The key point is to retrieve the Clerk userId from the request for use in our endpoints, and to return 401 Unauthorized if no user is logged in
GitHub
. This ensures our endpoints only operate for authenticated users.

/api/auth/clubSignup.ts – Club (Coach) Signup Endpoint

This endpoint is called after a coach/club owner completes Clerk sign-up. It finalizes the creation of a new organization (tenant) and links the current user to that tenant. Key steps:

Require authentication – The coach must be logged in (just created via Clerk) to proceed.

Parse input – Expect the club/organization details, e.g. name (club name), slug (desired slug/invite code). (The email can be obtained from Clerk or provided if needed for verification.)

Prevent duplicates – Check that the desired slug is not already taken by another Tenant. If it exists, respond with an error.

Create Tenant – Insert a new Tenant record in the database with the provided name and slug (and use the slug as the invite code).

Create User (if not exists) – Although the Clerk user is logged in, ensure we have a corresponding app User record. If one already exists (perhaps created by a middleware on first login), fetch it; otherwise, create a new User record with tenant_id set to the new tenant’s ID.

Assign role and owner – Mark this user as the owner/coach of the tenant (e.g. role = 'coach'). Update the Tenant’s owner_user_id to this user’s ID.

Return success – Respond with a success message or the newly created tenant info.

Example implementation (assuming a Next.js API route using the helpers above and Prisma):

// /api/auth/clubSignup.ts
import { prisma } from "@/lib/db";
import { requireAuth, getClerkUserId } from "@/lib/clerk";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }
  let clerkUserId: string;
  try {
    // Ensure the request is authenticated and get Clerk user ID
    clerkUserId = requireAuth(req, res);
  } catch {
    return; // requireAuth already sent 401 response
  }

  const { name: orgName, slug, email } = req.body;
  if (!orgName || !slug) {
    return res.status(400).json({ error: "Missing organization name or slug" });
  }

  // Ensure slug is alphanumeric/slug-safe (if needed, add validation)
  const tenantSlug = slug.toLowerCase().trim();

  try {
    // 1. Check for duplicate tenant slug
    const existingTenant = await prisma.tenant.findUnique({ where: { slug: tenantSlug } });
    if (existingTenant) {
      return res.status(409).json({ error: "This club slug is already taken. Please choose another." });
    }

    // 2. Create new Tenant
    const newTenant = await prisma.tenant.create({
      data: {
        name: orgName,
        slug: tenantSlug,
        invite_code: tenantSlug
        // owner_user_id will be set after creating the user
      }
    });

    // 3. Create or update User in our DB
    // Check if we already have a user record for this Clerk user (to avoid duplicates)
    let appUser = await prisma.user.findUnique({ where: { clerk_user_id: clerkUserId } });
    if (appUser) {
      // If user exists (perhaps from a pre-signup or previous partial registration), just update it
      appUser = await prisma.user.update({
        where: { id: appUser.id },
        data: {
          tenant_id: newTenant.id,
          role: "coach", 
          name: appUser.name || "",       // retain name if already set or update if needed
          email: appUser.email || email || ""  // use provided email if appUser email was empty
        }
      });
    } else {
      // Create a new user record for this Clerk user
      // Use any info from Clerk (email, name) if available
      const userName = req.body.name ?? "";       // If front-end passed a name (could be included in request)
      const userEmail = email ?? "";             // Email may be provided or could fetch via Clerk if needed
      appUser = await prisma.user.create({
        data: {
          clerk_user_id: clerkUserId,
          tenant_id: newTenant.id,
          role: "coach",
          name: userName,
          email: userEmail
        }
      });
    }

    // 4. Update tenant owner_user_id to reference this user
    await prisma.tenant.update({
      where: { id: newTenant.id },
      data: { owner_user_id: appUser.id }
    });

    return res.status(200).json({ 
      success: true, 
      message: "Club account created successfully",
      tenant: { id: newTenant.id, slug: newTenant.slug, name: newTenant.name },
      user: { id: appUser.id, role: appUser.role, tenant_id: appUser.tenant_id }
    });
  } catch (err) {
    console.error("Error in clubSignup:", err);
    return res.status(500).json({ error: "Server error creating club" });
  }
}


Notes:

We require the user to be authenticated via Clerk (using requireAuth). This will throw a 401 if the user isn’t logged in
GitHub
.

We ensure the slug is unique. If the slug (invite code) is already in use, we send a 409 Conflict so the frontend can prompt the coach to pick a different slug.

We either find an existing app user by the Clerk ID or create a new one. This guards against creating duplicate user entries if this endpoint is called multiple times or if a user record was created earlier (e.g., by a Clerk webhook or middleware). In case of migrating from a previous auth system, one might also check by email to link an existing record
GitHub
, but here we assume a fresh sign-up flow.

The email and name can be obtained from the request or directly from Clerk. If the front-end passes them (or you fetched via Clerk’s SDK), use those values. Clerk’s user object is also accessible via their SDK if needed.

Finally, we update the Tenant’s owner_user_id to point to this new user. The response returns some basic info (you can adjust as needed), confirming the creation.

/api/auth/basicSignup.ts – Basic (Parent/Player) Signup Endpoint

This endpoint runs after a parent/player user signs up via Clerk. It creates a User record without a tenant. Key steps:

Require authentication – The user must be logged in (just created via Clerk).

Create or find User – Check if a User record for this Clerk ID exists. If not, create one with tenant_id = NULL and role "member" (or "parent"/"player" as appropriate).

Return success – Possibly return the user record or a simple success.

Example implementation:

// /api/auth/basicSignup.ts
import { prisma } from "@/lib/db";
import { requireAuth } from "@/lib/clerk";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }
  let clerkUserId: string;
  try {
    clerkUserId = requireAuth(req, res);
  } catch {
    return;
  }

  try {
    // Check if a user record already exists for this Clerk user
    let appUser = await prisma.user.findUnique({ where: { clerk_user_id: clerkUserId } });
    if (!appUser) {
      // Create new user with no tenant (they haven't joined a club yet)
      appUser = await prisma.user.create({
        data: {
          clerk_user_id: clerkUserId,
          tenant_id: null,
          role: "member",  // default role for regular users
          // name and email can be set if available from Clerk
          name: req.body.name ?? "",
          email: req.body.email ?? ""
        }
      });
      console.log(`Created new user for Clerk ID ${clerkUserId}`);
    } else {
      console.log(`User for Clerk ID ${clerkUserId} already exists, skipping creation`);
    }

    return res.status(200).json({ success: true, user: { id: appUser.id, tenant_id: appUser.tenant_id, role: appUser.role } });
  } catch (err) {
    console.error("Error in basicSignup:", err);
    return res.status(500).json({ error: "Server error creating user" });
  }
}


Typically, if you have a Clerk middleware that auto-creates the user on first sign-in (like the syncClerkUser logic), calling this endpoint might be optional. However, having an explicit sign-up endpoint can be useful for clarity or custom logic (e.g., assigning default roles, logging, etc.). In any case, this ensures the app’s User table has an entry for the new user with no tenant association.

/api/tenant/join.ts – Join Club Endpoint

This endpoint allows a logged-in parent/player to join an existing club using an invite code. It should:

Require authentication – User must be logged in (we need their Clerk userId to know who is joining).

Parse input – Expect an invite code (the club slug) from the request body.

Validate – Check that the user is not already part of a tenant (their tenant_id should be null). If they already belong to a club, they shouldn’t join another (unless your app allows multiple memberships).

Find Tenant – Look up the Tenant by the provided invite code (slug).

If not found, return an error (invite code invalid).

If found, get the tenant’s ID (and optionally name, if needed for a response).

Update User – Set the user’s tenant_id to this tenant’s ID in the database, and update their role if needed (e.g., to "member" if not already).

Return success – Possibly return a message or updated user info.

Example implementation:

// /api/tenant/join.ts
import { prisma } from "@/lib/db";
import { requireAuth } from "@/lib/clerk";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }
  let clerkUserId: string;
  try {
    clerkUserId = requireAuth(req, res);
  } catch {
    return;
  }

  const { inviteCode } = req.body;
  if (!inviteCode) {
    return res.status(400).json({ error: "Invite code is required" });
  }
  const code = inviteCode.toLowerCase().trim();

  try {
    // 1. Find the tenant by invite code (slug)
    const tenant = await prisma.tenant.findUnique({ where: { slug: code } });
    if (!tenant) {
      return res.status(404).json({ error: "Invalid invite code. No club found with that code." });
    }

    // 2. Get the app user for the current Clerk user
    const appUser = await prisma.user.findUnique({ where: { clerk_user_id: clerkUserId } });
    if (!appUser) {
      return res.status(404).json({ error: "User not found in app database" });
    }
    if (appUser.tenant_id) {
      // User already in a tenant
      return res.status(400).json({ error: "You are already a member of a club." });
    }

    // 3. Update the user’s tenant and role
    const updatedUser = await prisma.user.update({
      where: { id: appUser.id },
      data: {
        tenant_id: tenant.id,
        role: "member"  // ensure role is member (or parent/player role)
      }
    });

    console.log(`User ${updatedUser.id} joined tenant ${tenant.id} (${tenant.slug})`);
    return res.status(200).json({ success: true, message: "Joined club successfully" });
  } catch (err) {
    console.error("Error in joinTenant:", err);
    return res.status(500).json({ error: "Server error joining club" });
  }
}


This will associate the logged-in user with the club’s tenant record. After this, the user’s tenant_id is no longer null, meaning they now belong to that club. The endpoint response is simple (success or error message).

Session Refresh Note: Upon successfully joining a tenant, the frontend may need to refresh the user’s session or data. Since the user’s role/tenant changed in our database, you might want to reflect this in the UI. You have a couple of options:

Sign the user out and back in – One strategy is to force a re-authentication. For example, immediately sign the user out on the client after a successful join and then redirect to the login page. When they log in again, the Clerk session will fetch the updated app user (now with a tenant) and load tenant-specific content. This approach ensures a clean state and is straightforward
GitHub
. The sample frontend code below demonstrates this approach.

Rehydrate user context – Alternatively, without logging out, you can refresh the app state. For instance, call /api/me again to get the updated user, update any global state or context with the new tenant_id, and redirect the user to the appropriate tenant dashboard. This avoids an extra login step, but you must ensure all components pick up the new tenant context.

Both approaches are valid. The logout/login approach is simple and guarantees the next session is correctly scoped
GitHub
 (as shown, a toast informs the user and then triggers signOut() and redirect). The direct refresh approach is more seamless but requires careful state management.

/api/me.ts – Current User Profile Endpoint (Optional)

For completeness, you can provide an endpoint to fetch the current user’s data from your database, including their tenant info. The frontend can call this after login to determine if the user has joined a club or not, and retrieve any profile details.

// /api/me.ts
import { prisma } from "@/lib/db";
import { requireAuth } from "@/lib/clerk";

export default async function handler(req, res) {
  let clerkUserId: string;
  try {
    clerkUserId = requireAuth(req, res);
  } catch {
    return;
  }

  try {
    const appUser = await prisma.user.findUnique({
      where: { clerk_user_id: clerkUserId },
      include: { tenant: true }  // include tenant details (name, slug) if needed
    });
    if (!appUser) {
      return res.status(404).json({ error: "User not found" });
    }
    // Return relevant user info (omit sensitive fields if any)
    return res.status(200).json({
      id: appUser.id,
      name: appUser.name,
      email: appUser.email,
      role: appUser.role,
      tenantId: appUser.tenant_id,
      tenantSlug: appUser.tenant ? appUser.tenant.slug : null,
      tenantName: appUser.tenant ? appUser.tenant.name : null
    });
  } catch (err) {
    console.error("Error in me:", err);
    return res.status(500).json({ error: "Failed to fetch user profile" });
  }
}


This is a simple helper endpoint. In practice, you might not need this if you pass user info in JWTs or use Clerk’s front-end APIs to get the user. However, having a dedicated endpoint to get the app-specific user data (especially the tenantId and any roles) can simplify the client logic.

Frontend Behavior and Usage

With the backend in place, the frontend should guide users through the appropriate flow:

Club Owner Sign-Up Flow: A coach/club owner goes to a “Sign up as a Club” page. This page might first collect the club details (name, desired slug) and then integrate the Clerk Sign-Up component.

Collect Club Info: The user enters the club name and slug (which will be their invite code). You might store this temporarily (in component state or context).

Clerk Sign-Up: Use Clerk’s <SignUp> component to handle the authentication. You can prefill the email or name if you collected them. For example, in a React component using @clerk/clerk-react:

<SignUp path="/signup/club" routing="path" 
       afterSignUpUrl="/signup/club/complete" 
       signInUrl="/login" />


(The afterSignUpUrl could be a route that triggers our clubSignup API call.)

After Sign-Up Callback: Once the Clerk sign-up is complete, the user is signed in. At this point, you should call the POST /api/auth/clubSignup endpoint to create the Tenant and link the user. If you stored the org name and slug in state, include them in this request. For example:

// Pseudo-code for after sign-up
const { user } = useUser();
useEffect(() => {
  if (user) {
    // user is the Clerk user object
    fetch("/api/auth/clubSignup", {
       method: "POST",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify({ 
          name: orgNameState,
          slug: slugState,
          email: user.primaryEmailAddress?.emailAddress 
       })
    }).then(res => res.json())
      .then(data => {
         if (data.success) {
           // maybe redirect to admin dashboard
           router.push("/admin/dashboard");
         } else {
           // handle error (slug taken, etc.)
         }
      });
  }
}, [user]);


In the example above, once the Clerk user is available (meaning sign-up succeeded), we call our API to create the tenant. On success, you could redirect the user to their new club’s dashboard (e.g., /admin/dashboard). On error, display a message (if slug is taken, you might let them retry with a new slug).

Note: The actual implementation can vary. In some cases, you might initiate the clubSignup API call on the server side (e.g., via a Clerk webhook or in a Next.js afterSignUp hook). But the above demonstrates a client-side approach for simplicity.

Parent/Player Sign-Up Flow: A regular user (consumer) goes to the standard sign-up page (e.g., "Join a Club" -> sign up).

They sign up using Clerk’s <SignUp> (possibly the default path). After signing up and logging in, you can call POST /api/auth/basicSignup to ensure their app user is created. If you have the Clerk middleware auto-creating users, this may already be handled. Otherwise, call the endpoint similarly to above:

if (clerkUserSignedIn) {
  fetch("/api/auth/basicSignup", { method: "POST" });
  // (You might not need to send anything in body if the server just uses Clerk session info)
}


After that, redirect or load the main app page for logged-in users.

Post-Login Tenant Check: Once a user is logged in (either just now, or on subsequent logins), fetch their app user profile (e.g., call /api/me). If the returned tenantId is null, it means this user hasn’t joined a club yet. In this case, you should prompt them to join.

Show a modal or dedicated page asking for the Invite Code (the club slug). The UI should explain that they need to enter the code provided by their club to gain access.

Example (React pseudo-code):

const [showJoinModal, setShowJoinModal] = useState(false);
useEffect(() => {
  fetch("/api/me")
    .then(res => res.json())
    .then(user => {
      if (user.tenantId === null) {
        setShowJoinModal(true);
      }
    });
}, []);


Then, in your modal component:

function JoinClubModal({ onJoined }) {
  const [code, setCode] = useState("");
  const { signOut } = useClerk();
  
  const submitCode = async () => {
    const res = await fetch("/api/tenant/join", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ inviteCode: code })
    });
    const data = await res.json();
    if (res.ok && data.success) {
      alert("Successfully joined the club! Please log in again to continue.");
      await signOut();  // log out to refresh session/context
      window.location.href = "/login"; // redirect to login (or use Clerk to navigate)
    } else {
      alert(data.error || "Failed to join. Please check the code and try again.");
    }
  };
  
  return (
    <Modal visible={true} title="Join a Club">
      <p>Enter your club's invite code to continue:</p>
      <input value={code} onChange={e => setCode(e.target.value)} placeholder="club-code" />
      <button onClick={submitCode}>Join Club</button>
    </Modal>
  );
}


In this snippet, on successful join, we notify the user and sign them out. Logging out immediately after joining is a simple way to ensure that when they log back in, all their context (like any Clerk organization or our app context) is fresh
GitHub
. The user can then log in and be directed to their club’s dashboard. Alternatively, instead of logging out, you could call onJoined() to refresh the user data and close the modal, if you prefer a seamless experience.

After Joining a Club: Once the user has a tenant, the app should tailor the experience to that club. For example, you might redirect them to /app/dashboard or a URL with the tenant slug. All subsequent API calls the user makes can include their tenant context (either through the session or by looking up user.tenant_id on the backend to scope data queries).

Coaches vs Members Access: Use the role field to control what the user can see or do. For instance, if user.role === 'coach', show admin/management controls; if 'member', limit to participant views. This RBAC logic can be handled in both frontend (for UX) and backend (for security, always enforce checks on protected routes). Clerk doesn’t inherently know about these roles — it’s up to your app’s logic.

Handling Existing Auth Conflicts and Best Practices

When integrating this new multi-tenant Clerk flow into an existing codebase, be mindful of conflicts with previous authentication or user-management logic:

Avoid Duplicate Users: If your app had an existing user system or if there’s a chance a Clerk user might already correspond to an existing user record (for example, from a legacy auth), you should link them instead of creating a new entry. The above code checks for an existing user by clerk_user_id. You could also check by email as a fallback to catch accounts that existed before Clerk
GitHub
. This prevents creating two separate user records for the same person.

Old Auth Flows: Remove or refactor any old signup/login flows that are not needed with Clerk. For example, if you previously had a custom email/password login or invitation system, those should be replaced by Clerk’s system. Make sure to migrate any necessary data (such as existing users’ emails into Clerk, if applicable) so that Clerk becomes the source of truth for authentication.

Session Management: Clerk manages the authentication session for you. Ensure any custom session or JWT logic from a prior system is disabled to avoid confusion. Instead, use Clerk’s session tokens or the getAuth() helper in your API routes to authenticate requests. In our endpoints, we call requireAuth (which uses getAuth) to ensure the user is logged in and get their ID
GitHub
.

Unique Tenant Constraints: The tenant slug being unique is important in a multi-tenant app. We handle this on the backend (409 error on duplicates). You might also want to check on the frontend (e.g., AJAX call to see if slug is available as the user types) for a better UX, but always enforce on the server. Similarly, ensure one user cannot accidentally create two tenants. In clubSignup, after creating a tenant and linking the user, you might want to prevent that user from calling it again (in our case, if they tried, the second time appUser.tenant_id would already be set, and you could respond with an error like "user already owns a club").

Invite Code Format: We used the tenant slug as the invite code for simplicity. Make sure to communicate to coaches what format the slug should be (e.g., all lowercase, no spaces, as shown in the UI). In the join modal placeholder above, we hinted the code is usually the club name in lowercase
GitHub
. You could also generate a random invite code instead of using the slug, storing both a human-friendly slug and a secure code. The flow would be similar, just look up by invite code.

Using Clerk Organizations (Optional): Clerk now supports Organizations, which can handle multi-tenant logic internally (letting users create organizations, invite others, and switch between orgs). In this custom implementation, we managed tenants in our own database. This gives more control and is fine for many apps. If desired, explore Clerk’s organizations for built-in support – but note that if a user can belong to multiple orgs, your app logic would need to handle switching contexts. In our scenario, each user is tied to a single tenant at a time (one club), which keeps things simpler.

Webhooks and Background Operations: As a best practice, consider using Clerk webhooks for certain events. For example, Clerk can send a webhook when a new user signs up or an email is verified. You could use that to eagerly create the user in your DB (instead of doing it on the first authenticated request). Also, if you wanted to trigger actions when a user joins a tenant (like sending a welcome email or notifying the club admins), the point after updating tenant_id is where to do it. Our implementation kept things straightforward, but you can extend it with such features.

Code Quality: All code is written with clarity in mind:

We use meaningful naming (e.g., tenant_id, owner_user_id, clubSignup endpoint) that reflects their purpose.

Comments and console logs (which you might remove in production) are included to explain steps and aid debugging.

Errors are handled with appropriate status codes and messages to the client (400 for bad input, 404 for not found, 409 for conflicts, 500 for server issues).

Sensitive operations like creating users or joining tenants are protected by auth checks to prevent abuse.

By implementing the above flows, you’ll have a robust multi-tenant authentication system. Coaches/Clubs can sign up and automatically get their own tenant space, and Parents/Players can join those spaces via an invite code. The Clerk integration takes care of secure authentication, while your app logic ensures each user ends up associated with the correct tenant. This design is scalable and maintainable, and it cleanly replaces any prior single-tenant auth logic with a modern, multi-tenant approach using Clerk.