Your app has two user types.

One is a coach or club.
They create an account on your website and that becomes an Organization or Tenant inside your database.
They authenticate with Clerk.
Your app stores a user record that is linked to their Clerk user ID.
Your app then generates an invite code which is the club slug.
This invite code is tied to the club tenant.

The second type is a parent or player.
They create an account on your site, but at first they have no tenant connection.
Your app stores a user record that is linked to their Clerk user ID, but with tenant set to null.

The entire flow needs to keep Clerk as the identity provider and keep your database as the source of truth for tenants, invite codes, and tenant membership.

Below explains everything you need to build with the agent.

Step 1. When a coach or club signs up

1. Coach visits your signup page
They create an account using Clerk.
Clerk returns the user ID.

2. Your backend creates the club tenant
Right after Clerk returns the user ID, your backend creates a Tenant row using the following fields:

• org name
• org slug
• owner user id
• invite code which equals the slug
• created at timestamp

3. Your backend creates the app user linked to Clerk
Inside your Users table:
• id (uuid)
• clerk_user_id
• tenant_id (the tenant you created)
• user role (owner or coach)
• email, name, phone as needed

At this point the coach is fully authenticated inside Clerk and fully mapped inside your database.

Step 2. When a parent or player signs up

1. Parent visits playhq.app and signs up using Clerk
You create a Users row with:
• id (uuid)
• clerk_user_id
• tenant_id set to null
• role set to parent or player

2. Detect that they have no tenant
When the frontend loads after login, your app checks the user record.

If tenant is null, you show the join tenant modal.

The modal can be closed and re opened from settings.

Step 3. When a user enters their invite code

The invite code is the club slug.
Your backend looks up the Tenant where slug equals the code.

If nothing matches, show an invalid code message.

If it matches, you add the user to that tenant.

Backend behavior:
• Update the Users table where clerk_user_id equals the current user
• Set tenant_id to the tenant that matches the slug
• Optionally set role to parent or player
• Save and return the updated user plus the tenant info

Step 4. After a user joins a tenant

You have two possible approaches. Both are clean and easy to implement.

Option A. Require logout and login

This is the simplest.
After updating the user, you call Clerk sign out.
Then redirect to the login page.
Once they log in, Clerk returns their identity and your database sees the updated tenant id.
The frontend loads the tenant specific sessions and pages.

Option B. No logout needed

Clerk allows you to update the app session without forcing a new login.
Your backend returns the updated user and tenant data.
Your frontend updates local state, rerenders the pages, and loads the tenant sessions immediately.
No login loop is required.
This is a smoother experience and very common in multi tenant apps.

Either option works, but Option B is more user friendly.

Step 5. What Replit needs to build

Here is the technical definition that the agent needs to follow.

Database tables required

Users
• id
• clerk_user_id
• tenant_id
• role
• name
• email
• phone

Tenants
• id
• name
• slug
• invite_code (equals slug)
• owner_user_id
• created_at

Backend routes required

POST /api/auth/club signup
• Takes new user info
• Uses Clerk to create or read user
• Creates tenant with slug and invite code
• Creates user record mapped to Clerk user
• Returns tenant and user

POST /api/auth/create basic user
• Called when a parent signs up
• Reads Clerk user
• Creates user with tenant null
• Returns user

POST /api/tenant join
• Body contains invite code
• Backend validates invite code
• Updates user tenant_id
• Returns updated user and tenant

Frontend logic

After Clerk login, call your backend to get the app user.
If tenant_id is null, show the join modal.
After join, update user state or trigger logout and login depending on which option you pick.

Step 6. Clean summary for the agent

You can copy and paste this part into Replit word for word if you want.

Summary to give the agent

We have two user types. Clubs and coaches create an account which creates a tenant in our database. The tenant gets a slug which is also the invite code. The coach user is stored in the Users table and linked to Clerk through clerk_user_id.

Parents or players create a basic account in Clerk, and then the backend creates a Users row with tenant_id set to null.

When a user with a null tenant logs in, the frontend shows a modal asking for their invite code. The code equals the club slug. When the user enters the code, the backend looks up the tenant and updates the Users table to assign the tenant_id. You can either sign the user out and require login again or refresh their session and rerender the frontend to load the tenant data.

The core requirement is to map Clerk users to our Users table, attach tenants based on an invite code, and load tenant specific content only after the user is linked to a tenant.